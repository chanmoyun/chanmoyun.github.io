<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>禅墨云</title>
  
  
  <link href="https://chanmoyun.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://chanmoyun.gitee.io/"/>
  <updated>2024-02-29T13:02:29.248Z</updated>
  <id>https://chanmoyun.gitee.io/</id>
  
  <author>
    <name>Chanmo Jia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>07|队列：队列在线程池等有限资源池中的应用</title>
    <link href="https://chanmoyun.gitee.io/2024/02/29/Data-structure/07.%E9%98%9F%E5%88%97%EF%BC%9A%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://chanmoyun.gitee.io/2024/02/29/Data-structure/07.%E9%98%9F%E5%88%97%EF%BC%9A%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2024-02-28T16:00:00.000Z</published>
    <updated>2024-02-29T13:02:29.248Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="队列：队列在线程池等有限资源池中的应用"><a href="#队列：队列在线程池等有限资源池中的应用" class="headerlink" title="队列：队列在线程池等有限资源池中的应用"></a>队列：队列在线程池等有限资源池中的应用</h1><p>我们知道，CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p><p><strong>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</strong></p><p>实际上，这些问题并不复杂，其底层的数据结构就是我们今天要学的内容，队列（queue）。</p><h2 id="如何理解“队列”？"><a href="#如何理解“队列”？" class="headerlink" title="如何理解“队列”？"></a>如何理解“队列”？</h2><p>队列这个概念非常好理解。你可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。<strong>先进者先出，这就是典型的“队列”。</strong></p><p>我们知道，栈只支持两个基本操作：<strong>入栈 push()和出栈 pop()</strong>。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：<strong>入队 enqueue()</strong>，放一个数据到队列尾部；<strong>出队 dequeue()</strong>，从队列头部取一个元素。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/9%201.jpg" alt=""></p><p>所以，队列跟栈一样，也是一种<strong>操作受限的线性表数据结构。</strong></p><p>队列的概念很好理解，基本操作也很容易掌握。作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。</p><h2 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h2><p>我们知道了，队列跟栈一样，也是一种抽象的数据结构。它具有先进先出的特性，支持在队尾插入元素，在队头删除元素，那究竟该如何实现一个队列呢？</p><p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p><p>我们先来看下基于数组的实现方法。我用 Java 语言实现了一下，不过并不包含 Java 语言的高级语法，而且我做了比较详细的注释，你应该可以看懂。</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 用数组实现的队列</span><br><span class="line">public class ArrayQueue &#123;</span><br><span class="line">  // 数组：items，数组大小：n</span><br><span class="line">  private String[] items;</span><br><span class="line">  private int n = 0;</span><br><span class="line">  // head表示队头下标，tail表示队尾下标</span><br><span class="line">  private int head = 0;</span><br><span class="line">  private int tail = 0;</span><br><span class="line"></span><br><span class="line">  // 申请一个大小为capacity的数组</span><br><span class="line">  public ArrayQueue(int capacity) &#123;</span><br><span class="line">    items = new String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 入队</span><br><span class="line">  public boolean enqueue(String item) &#123;</span><br><span class="line">    // 如果tail == n 表示队列已经满了</span><br><span class="line">    if (tail == n) return false;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    ++tail;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 出队</span><br><span class="line">  public String dequeue() &#123;</span><br><span class="line">    // 如果head == tail 表示队列为空</span><br><span class="line">    if (head == tail) return null;</span><br><span class="line">    // 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    ++head;</span><br><span class="line">    return ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>比起栈的数组实现，队列的数组实现稍微有点儿复杂，但是没关系。我稍微解释一下实现思路，你很容易就能明白了。</p><p>对于栈来说，我们只需要一个<strong>栈顶指针</strong>就可以了。但是队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾</p><p>。你可以结合下面这幅图来理解。当 a、b、c、d 依次入队之后，队列中的 head 指针指向下标为 0 的位置，tail 指针指向下标为 4 的位置。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/9%202.jpg" alt=""></p><p>当我们调用两次出队操作之后，队列中 head 指针指向下标为 2 的位置，tail 指针仍然指向下标为 4 的位置。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/9%203.jpg" alt=""></p><p>你肯定已经发现了，随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题该如何解决呢？</p><p>你是否还记得，在数组那一节，我们也遇到过类似的问题，就是数组的删除操作会导致数组中的数据不连续。你还记得我们当时是怎么解决的吗？对，用<strong>数据搬移</strong>！但是，每次进行出队操作都相当于删除数组下标为 0 的数据，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的 O(1) 变为 O(n)。能不能优化一下呢？</p><p>实际上，我们在出队时可以不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。借助这个思想，出队函数 dequeue() 保持不变，我们稍加改造一下入队函数 enqueue() 的实现，就可以轻松解决刚才的问题了。下面是具体的代码：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 入队操作，将item放入队尾</span><br><span class="line">public boolean enqueue(String item) &#123;</span><br><span class="line">  // tail == n表示队列末尾没有空间了</span><br><span class="line">  if (tail == n) &#123;</span><br><span class="line">    // tail ==n &amp;&amp; head==0，表示整个队列都占满了</span><br><span class="line">    if (head == 0) return false;</span><br><span class="line">    // 数据搬移</span><br><span class="line">    for (int i = head; i &lt; tail; ++i) &#123;</span><br><span class="line">      items[i-head] = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    // 搬移完之后重新更新head和tail</span><br><span class="line">    tail -= head;</span><br><span class="line">    head = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  items[tail] = item;</span><br><span class="line">  ++tail;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码中我们看到，当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，我们可以将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/9%204.jpg" alt=""></p><p>这种实现思路中，出队操作的时间复杂度仍然是 O(1)，但入队操作的时间复杂度还是 O(1) 吗？你可以用我们第 3 节、第 4 节讲的算法复杂度分析方法，自己试着分析一下。</p><p>接下来，我们再来看下<strong>基于链表的队列实现方法</strong>。</p><p>基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。如图所示，入队时，tail-&gt;next= new_node, tail = tail-&gt;next；出队时，head = head-&gt;next。我将具体的代码放到 GitHub 上，你可以自己试着实现一下，然后再去 GitHub 上跟我实现的代码对比下，看写得对不对。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/9%205.jpg" alt=""></p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>我们刚才用数组来实现队列的时候，在 tail==n 时，会有数据搬移操作，这样入队操作性能就会受到影响。那有没有办法能够避免数据搬移呢？我们来看看循环队列的解决思路。</p><p>循环队列，顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。我画了一张图，你可以直观地感受一下。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/9%206.jpg" alt=""></p><p>我们可以看到，图中这个队列的大小为 8，当前 head=4，tail=7。当有一个新的元素 a 入队时，我们放入下标为 7 的位置。但这个时候，我们并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 b 入队时，我们将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1。所以，在 a，b 依次入队之后，循环队列中的元素就变成了下面的样子：</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/9%207.jpg" alt=""></p><p>通过这样的方法，我们成功避免了数据搬移操作。看起来不难理解，但是循环队列的代码实现难度要比前面讲的非循环队列难多了。要想写出没有 bug 的循环队列的实现代码，我个人觉得，最关键的是，<strong>确定好队空和队满的判定条件</strong>。</p><p>在用数组实现的非循环队列中，队满的判断条件是 tail == n，队空的判断条件是 head == tail。那针对循环队列，如何判断队空和队满呢？</p><p>队列为空的判断条件仍然是 head == tail。但队列满的判断条件就稍微有点复杂了。我画了一张队列满的图，你可以看一下，试着总结一下规律。</p><p><img src="D:\Desktop\BaiduSyncdisk\MD草稿\数据结构与算法\img\9 8.jpg" alt=""></p><p>就像我图中画的队满的情况，tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，<strong>(tail+1)%n=head</strong>。</p><p>你有没有发现，当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。</p><p>Talk is cheap，如果还是没怎么理解，那就 show you code 吧。</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class CircularQueue &#123;</span><br><span class="line">  // 数组：items，数组大小：n</span><br><span class="line">  private String[] items;</span><br><span class="line">  private int n = 0;</span><br><span class="line">  // head表示队头下标，tail表示队尾下标</span><br><span class="line">  private int head = 0;</span><br><span class="line">  private int tail = 0;</span><br><span class="line"></span><br><span class="line">  // 申请一个大小为capacity的数组</span><br><span class="line">  public CircularQueue(int capacity) &#123;</span><br><span class="line">    items = new String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 入队</span><br><span class="line">  public boolean enqueue(String item) &#123;</span><br><span class="line">    // 队列满了</span><br><span class="line">    if ((tail + 1) % n == head) return false;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail = (tail + 1) % n;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 出队</span><br><span class="line">  public String dequeue() &#123;</span><br><span class="line">    // 如果head == tail 表示队列为空</span><br><span class="line">    if (head == tail) return null;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    head = (head + 1) % n;</span><br><span class="line">    return ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h2><p>前面讲的内容理论比较多，看起来很难跟实际的项目开发扯上关系。确实，队列这种数据结构很基础，平时的业务开发不大可能从零实现一个队列，甚至都不会直接用到。而一些具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。</p><p>阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/9%2010.jpg" alt=""></p><p>你应该已经发现了，上述的定义就是一个“生产者 - 消费者模型”！是的，我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”！</p><p>这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p><p>而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/9%2011.jpg" alt=""></p><p>前面我们讲了阻塞队列，在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢？</p><p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。在实战篇讲 Disruptor 的时候，我会再详细讲并发队列的应用。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>队列的知识就讲完了，我们现在回过来看下开篇的问题。线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</p><p>我们一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？</p><p>我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。我们前面说过，队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？</p><p>基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</p><p>而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</p><p>除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。<strong>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队</strong>。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们讲了一种跟栈很相似的数据结构，队列。关于队列，你能掌握下面的内容，这节就没问题了。</p><p>队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。</p><p>在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。循环队列是我们这节的重点。要想写出没有 bug 的循环队列实现代码，关键要确定好队空和队满的判定条件，具体的代码你要能写出来。</p><p>除此之外，我们还讲了几种高级的队列结构，阻塞队列、并发队列，底层都还是队列这种数据结构，只不过在之上附加了很多其他功能。阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？</p><p>今天讲到并发队列，关于如何实现无锁并发队列，网上有非常多的讨论。对这个问题，你怎么看呢？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>06|栈：如何实现浏览器的前进和后退功能？</title>
    <link href="https://chanmoyun.gitee.io/2024/02/28/Data-structure/06.%E6%A0%88%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD%EF%BC%9F/"/>
    <id>https://chanmoyun.gitee.io/2024/02/28/Data-structure/06.%E6%A0%88%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD%EF%BC%9F/</id>
    <published>2024-02-27T16:00:00.000Z</published>
    <updated>2024-02-29T13:02:21.705Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="栈：如何实现浏览器的前进和后退功能？"><a href="#栈：如何实现浏览器的前进和后退功能？" class="headerlink" title="栈：如何实现浏览器的前进和后退功能？"></a>栈：如何实现浏览器的前进和后退功能？</h1><p>浏览器的前进、后退功能，我想你肯定很熟悉吧？</p><p>当你依次访问完一串页面 a-b-c 之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面 b 和 a。当你后退到页面 a，点击前进按钮，就可以重新查看页面 b 和 c。但是，如果你后退到页面 b 后，点击了新的页面 d，那就无法再通过前进、后退功能查看页面 c 了。</p><p><strong>假设你是 Chrome 浏览器的开发工程师，你会如何实现这个功能呢？</strong></p><p>这就要用到我们今天要讲的“栈”这种数据结构。带着这个问题，我们来学习今天的内容。</p><p><strong>如何理解“栈”？</strong></p><p>关于“栈”，我有一个非常贴切的例子，就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一个放；取的时候，我们也是从上往下一个一个地依次取，不能从中间任意抽出。<strong>后进者先出，先进者后出，这就是典型的“栈”结构。</strong></p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/8%201.jpg" alt=""></p><p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表</strong>，只允许在一端插入和删除数据。</p><p>我第一次接触这种数据结构的时候，就对它存在的意义产生了很大的疑惑。因为我觉得，相比数组和链表，栈带给我的只有限制，并没有任何优势。那我直接使用数组或者链表不就好了吗？为什么还要用这个“操作受限”的“栈”呢？</p><p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p><p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</strong></p><p><strong>如何实现一个“栈”？</strong></p><p>从刚才栈的定义里，我们可以看出，栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。理解了栈的定义之后，我们来看一看如何用代码实现一个栈。</p><p>实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p><p>我这里实现一个基于数组的顺序栈。基于链表实现的链式栈的代码，你可以自己试着写一下。我会将我写好的代码放到 Github 上，你可以去看一下自己写的是否正确。</p><p>我这段代码是用 Java 来实现的，但是不涉及任何高级语法，并且我还用中文做了详细的注释，所以你应该是可以看懂的。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 基于数组实现的顺序栈</span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">  private String[] items;  // 数组</span><br><span class="line">  private <span class="built_in">int</span> count;       // 栈中元素个数</span><br><span class="line">  private <span class="built_in">int</span> n;           //栈的大小</span><br><span class="line"></span><br><span class="line">  // 初始化数组，申请一个大小为n的数组空间</span><br><span class="line">  public ArrayStack(<span class="built_in">int</span> n) &#123;</span><br><span class="line">    this.items = new String[n];</span><br><span class="line">    this.n = n;</span><br><span class="line">    this.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 入栈操作</span><br><span class="line">  public boolean push(String item) &#123;</span><br><span class="line">    // 数组空间不够了，直接返回false，入栈失败。</span><br><span class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> false;</span><br><span class="line">    // 将item放到下标为count的位置，并且count加一</span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> true;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 出栈操作</span><br><span class="line">  public String pop() &#123;</span><br><span class="line">    // 栈为空，则直接返回null</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> null;</span><br><span class="line">    // 返回下标为count-<span class="number">1</span>的数组元素，并且栈中元素个数count减一</span><br><span class="line">    String tmp = items[count-<span class="number">1</span>];</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>了解了定义和基本操作，那它的操作的时间、空间复杂度是多少呢？</p><p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为 n 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。</p><p>注意，这里存储数据需要一个大小为 n 的数组，并不是说空间复杂度就是 O(n)。因为，这 n 个空间是必须的，无法省掉。所以我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。</p><p>空间复杂度分析是不是很简单？时间复杂度也不难。不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)。</p><h2 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h2><p>刚才那个基于数组实现的栈，是一个固定大小的栈，也就是说，在初始化栈时需要事先指定栈的大小。当栈满之后，就无法再往栈里添加数据了。尽管链式栈的大小不受限，但要存储 next 指针，内存消耗相对较多。那我们如何基于数组实现一个可以支持动态扩容的栈呢？</p><p>你还记得，我们在数组那一节，是如何来实现一个支持动态扩容的数组的吗？当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。</p><p>所以，如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。我画了一张图，你可以对照着理解一下。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/8%202.jpg" alt=""></p><p>实际上，支持动态扩容的顺序栈，我们平时开发中并不常用到。我讲这一块的目的，主要还是希望带你练习一下前面讲的复杂度分析方法。所以这一小节的重点是复杂度分析。</p><p>你不用死记硬背入栈、出栈的时间复杂度，你需要掌握的是分析方法。能够自己分析才算是真正掌握了。现在我就带你分析一下支持动态扩容的顺序栈的入栈、出栈操作的时间复杂度。</p><p>对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 O(1)。但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)。</p><p>也就是说，对于入栈操作来说，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)。那平均情况下的时间复杂度又是多少呢？还记得我们在复杂度分析那一节中讲的摊还分析法吗？这个入栈操作的平均情况下的时间复杂度可以用摊还分析法来分析。我们也正好借此来实战一下摊还分析法。</p><p>为了分析的方便，我们需要事先做一些假设和定义：</p><ul><li>栈空间不够时，我们重新申请一个是原来大小两倍的数组；</li><li>为了简化分析，假设只有入栈操作没有出栈操作；</li><li>定义不涉及内存搬移的入栈操作为 simple-push 操作，时间复杂度为 O(1)。</li></ul><p>如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-push 操作就可以完成。为了让你更加直观地理解这个过程，我画了一张图。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/8%203.jpg" alt=""></p><p>你应该可以看出来，这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，入栈操作的均摊时间复杂度就为 O(1)。</p><p>通过这个例子的实战分析，也印证了前面讲到的，均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度 O 都是 O(1)，只有在个别时刻才会退化为 O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 O(1)。</p><h2 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h2><p>前面我讲的都比较偏理论，我们现在来看下，栈在软件工程中的实际应用。栈作为一个比较基础的数据结构，应用场景还是蛮多的。其中，比较经典的一个应用场景就是<strong>函数调用栈</strong>。</p><p>我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。为了让你更好地理解，我们一块来看下这段代码的执行过程。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">   <span class="built_in">int</span> a = <span class="number">1</span>; </span><br><span class="line">   <span class="built_in">int</span> ret = <span class="number">0</span>;</span><br><span class="line">   <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">   ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   printf(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">   reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> add(<span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123;</span><br><span class="line">   <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="built_in">sum</span> = x + y;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码中我们可以看出，main() 函数调用了 add() 函数，获取计算结果，并且与临时变量 a 相加，最后打印 res 的值。为了让你清晰地看到这个过程对应的函数栈里出栈、入栈的操作，我画了一张图。图中显示的是，在执行到 add() 函数时，函数调用栈的情况。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/8%204.jpg" alt=""></p><p>栈在表达式求值中的应用</p><p>我们再来看栈的另一个常见的应用场景，编译器如何利用栈来实现<strong>表达式求值</strong>。</p><p>为了方便解释，我将算术表达式简化为只包含加减乘除四则运算，比如：34+139+44-12/3。对于这个四则运算，我们人脑可以很快求解出答案，但是对于计算机来说，理解这个表达式本身就是个挺难的事儿。如果换作你，让你来实现这样一个表达式求值的功能，你会怎么做呢？</p><p>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p><p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p><p>我将 3+58-6 这个表达式的计算过程画成了一张图，你可以结合图来理解我刚讲的计算过程。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/8%205.jpg" alt=""></p><p>这样用两个栈来解决的思路是不是非常巧妙？你有没有想到呢？</p><h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><p>除了用栈来实现表达式求值，我们还可以借助栈来检查表达式中的括号是否匹配。</p><p>我们同样简化一下背景。我们假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，{[] ()[{}]}或[{()}([])]等都为合法格式，而{[}()]或[({)]为不合法的格式。那我现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？</p><p>这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p><p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>好了，我想现在你已经完全理解了栈的概念。我们再回来看看开篇的思考题，如何实现浏览器的前进、后退功能？其实，用两个栈就可以非常完美地解决这个问题。</p><p>我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。</p><p>当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。比如你顺序查看了 a，b，c 三个页面，我们就依次把 a，b，c 压入栈，这个时候，两个栈的数据就是这个样子：</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/8%206.jpg" alt="">)</p><p>当你通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，我们就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y。这个时候，两个栈的数据就是这个样子：</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/8%207.jpg" alt=""></p><p>这个时候你又想看页面 b，于是你又点击前进按钮回到 b 页面，我们就把 b 再从栈 Y 中出栈，放入栈 X 中。此时两个栈的数据是这个样子：</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/8%208.jpg" alt=""></p><p>这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。此时两个栈的数据这个样子：</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/8%209.jpg" alt=""></p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>我们来回顾一下今天讲的内容。栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是它最大的特点。栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。除此之外，我们还讲了一种支持动态扩容的顺序栈，你需要重点掌握它的均摊时间复杂度分析方法。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>1.我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</p><p>2.我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>05|链表（下）：如何轻松写出正确的链表代码？</title>
    <link href="https://chanmoyun.gitee.io/2024/02/27/Data-structure/05.%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E8%BD%BB%E6%9D%BE%E5%86%99%E5%87%BA%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%EF%BC%9F/"/>
    <id>https://chanmoyun.gitee.io/2024/02/27/Data-structure/05.%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E8%BD%BB%E6%9D%BE%E5%86%99%E5%87%BA%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%EF%BC%9F/</id>
    <published>2024-02-26T16:00:00.000Z</published>
    <updated>2024-02-29T13:01:47.865Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="链表（下）：如何轻松写出正确的链表代码？"><a href="#链表（下）：如何轻松写出正确的链表代码？" class="headerlink" title="链表（下）：如何轻松写出正确的链表代码？"></a>链表（下）：如何轻松写出正确的链表代码？</h1><p>上一节我讲了链表相关的基础知识。学完之后，我看到有人留言说，基础知识我都掌握了，但是写链表代码还是很费劲。哈哈，的确是这样的！</p><p>想要写好链表代码并不是容易的事儿，尤其是那些复杂的链表操作，比如链表反转、有序链表合并等，写的时候非常容易出错。从我上百场面试的经验来看，能把“链表反转”这几行代码写对的人不足 10%。</p><p>为什么链表代码这么难写？究竟怎样才能比较轻松地写出正确的链表代码呢？</p><p>只要愿意投入时间，我觉得大多数人都是可以学会的。比如说，如果你真的能花上一个周末或者一整天的时间，就去写链表反转这一个代码，多写几遍，一直练到能毫不费力地写出 Bug free 的代码。这个坎还会很难跨吗？</p><p>当然，自己有决心并且付出精力是成功的先决条件，除此之外，我们还需要一些方法和技巧。我根据自己的学习经历和工作经验，总结了<strong>几个写链表代码技巧</strong>。如果你能熟练掌握这几个技巧，加上你的主动和坚持，轻松拿下链表代码完全没有问题。</p><h2 id="技巧一：理解指针或引用的含义"><a href="#技巧一：理解指针或引用的含义" class="headerlink" title="技巧一：理解指针或引用的含义"></a>技巧一：理解指针或引用的含义</h2><p>事实上，看懂链表的结构并不是很难，但是一旦把它和指针混在一起，就很容易让人摸不着头脑。所以，要想写对链表代码，首先就要理解好指针。</p><p>我们知道，有些语言有“指针”的概念，比如 C 语言；有些语言没有指针，取而代之的是“引用”，比如 Java、Python。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。</p><p>接下来，我会拿 C 语言中的“指针”来讲解，如果你用的是 Java 或者其他没有指针的语言也没关系，你把它理解成“引用”就可以了。</p><p>实际上，对于指针的理解，你只需要记住下面这句话就可以了：</p><p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p><p>这句话听起来还挺拗口的，你可以先记住。我们回到链表代码的编写过程中，我来慢慢给你解释。在编写链表代码的时候，我们经常会有这样的代码：p-&gt;next=q。这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。</p><p>还有一个更复杂的，也是我们写链表代码经常会用到的：p-&gt;next=p-&gt;next-&gt;next。这行代码表示，p 结点的 next 指针存储了 p 结点的下一个结点的内存地址。</p><p>掌握了指针或引用的概念，你应该可以很轻松地看懂链表代码。恭喜你，已经离写出链表代码近了一步！</p><h2 id="技巧二：警惕指针丢失和内存泄漏"><a href="#技巧二：警惕指针丢失和内存泄漏" class="headerlink" title="技巧二：警惕指针丢失和内存泄漏"></a>技巧二：警惕指针丢失和内存泄漏</h2><p>不知道你有没有这样的感觉，写链表代码的时候，指针指来指去，一会儿就不知道指到哪里了。所以，我们在写的时候，一定注意不要弄丢了指针。</p><p>指针往往都是怎么弄丢的呢？我拿单链表的插入操作为例来给你分析一下。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/7%201.jpg" alt=""></p><p>如图所示，我们希望在结点 a 和相邻的结点 b 之间插入结点 x，假设当前指针 p 指向结点 a。如果我们将代码实现变成下面这个样子，就会发生指针丢失和内存泄露。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">next</span> = x;  // 将p的<span class="built_in">next</span>指针指向x结点；</span><br><span class="line">x-&gt;<span class="built_in">next</span> = p-&gt;<span class="built_in">next</span>;  // 将x的结点的<span class="built_in">next</span>指针指向b结点；</span><br></pre></td></tr></table></figure></p><p>初学者经常会在这儿犯错。p-&gt;next 指针在完成第一步操作之后，已经不再指向结点 b 了，而是指向结点 x。第 2 行代码相当于将 x 赋值给 x-&gt;next，自己指向自己。因此，整个链表也就断成了两半，从结点 b 往后的所有结点都无法访问到了。</p><p>对于有些语言来说，比如 C 语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。所以，我们<strong>插入结点时，一定要注意操作的顺序</strong>，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。所以，对于刚刚的插入代码，我们只需要把第 1 行和第 2 行代码的顺序颠倒一下就可以了。</p><p>同理，<strong>删除链表结点时，也一定要记得手动释放内存空间</strong>，否则，也会出现内存泄漏的问题。当然，对于像 Java 这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。</p><h2 id="技巧三：利用哨兵简化实现难度"><a href="#技巧三：利用哨兵简化实现难度" class="headerlink" title="技巧三：利用哨兵简化实现难度"></a>技巧三：利用哨兵简化实现难度</h2><p>首先，我们先来回顾一下单链表的插入和删除操作。如果我们在结点 p 后面插入一个新的结点，只需要下面两行代码就可以搞定。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">new_node-&gt;<span class="built_in">next</span> = p-&gt;<span class="built_in">next</span>;</span><br><span class="line">p-&gt;<span class="built_in">next</span> = new_node;</span><br></pre></td></tr></table></figure></p><p>但是，当我们要向一个空链表中插入第一个结点，刚刚的逻辑就不能用了。我们需要进行下面这样的特殊处理，其中 head 表示链表的头结点。所以，从这段代码，我们可以发现，对于单链表的插入操作，第一个结点和其他结点的插入逻辑是不一样的。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (head == null) &#123;</span><br><span class="line">  head = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再来看单链表结点删除操作。如果要删除结点 p 的后继结点，我们只需要一行代码就可以搞定。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">next</span> = p-&gt;<span class="built_in">next</span>-&gt;<span class="built_in">next</span>;</span><br></pre></td></tr></table></figure></p><p>但是，如果我们要删除链表中的最后一个结点，前面的删除代码就不 work 了。跟插入类似，我们也需要对于这种情况特殊处理。写成代码是这样子的：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (head-&gt;<span class="built_in">next</span> == null) &#123;</span><br><span class="line">   head = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从前面的一步一步分析，我们可以看出，<strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</strong>。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。如何来解决这个问题呢？</p><p>技巧三中提到的哨兵就要登场了。哨兵，解决的是国家之间的边界问题。同理，这里说的哨兵也是解决“边界问题”的，不直接参与业务逻辑。</p><p>还记得如何表示一个空链表吗？head=null 表示链表中没有结点了。其中 head 表示头结点指针，指向链表中的第一个结点。</p><p>如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫<strong>带头链表</strong>。相反，没有哨兵结点的链表就叫作<strong>不带头链表</strong>。</p><p>我画了一个带头链表，你可以发现，哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/7%202.jpg" alt=""></p><p>实际上，这种利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。这些内容我们后面才会讲，现在为了让你感受更深，我再举一个非常简单的例子。代码我是用 C 语言实现的，不涉及语言方面的高级语法，很容易看懂，你可以类比到你熟悉的语言。</p><p>代码一：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 在数组a中，查找key，返回key所在的位置</span><br><span class="line">// 其中，n表示数组a的长度</span><br><span class="line"><span class="built_in">int</span> find(char* a, <span class="built_in">int</span> n, char key) &#123;</span><br><span class="line">  // 边界条件处理，如果a为空，或者n&lt;=<span class="number">0</span>，说明数组中没有数据，就不用<span class="keyword">while</span>循环比较了</span><br><span class="line">  <span class="keyword">if</span>(a == null || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">  // 这里有两个比较操作：i&lt;n和a[i]==key.</span><br><span class="line">  <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == key) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码二：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 在数组a中，查找key，返回key所在的位置</span><br><span class="line">// 其中，n表示数组a的长度</span><br><span class="line">// 我举<span class="number">2</span>个例子，你可以拿例子走一下代码</span><br><span class="line">// a = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">6</span>&#125;  n=<span class="number">6</span> key = <span class="number">7</span></span><br><span class="line">// a = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">6</span>&#125;  n=<span class="number">6</span> key = <span class="number">6</span></span><br><span class="line"><span class="built_in">int</span> find(char* a, <span class="built_in">int</span> n, char key) &#123;</span><br><span class="line">  <span class="keyword">if</span>(a == null || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 这里因为要将a[n-<span class="number">1</span>]的值替换成key，所以要特殊处理这个值</span><br><span class="line">  <span class="keyword">if</span> (a[n-<span class="number">1</span>] == key) &#123;</span><br><span class="line">    <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 把a[n-<span class="number">1</span>]的值临时保存在变量tmp中，以便之后恢复。tmp=<span class="number">6</span>。</span><br><span class="line">  // 之所以这样做的目的是：希望find()代码不要改变a数组中的内容</span><br><span class="line">  char tmp = a[n-<span class="number">1</span>];</span><br><span class="line">  // 把key的值放到a[n-<span class="number">1</span>]中，此时a = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>&#125;</span><br><span class="line">  a[n-<span class="number">1</span>] = key;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">  // <span class="keyword">while</span> 循环比起代码一，少了i&lt;n这个比较操作</span><br><span class="line">  <span class="keyword">while</span> (a[i] != key) &#123;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 恢复a[n-<span class="number">1</span>]原来的值,此时a= &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">6</span>&#125;</span><br><span class="line">  a[n-<span class="number">1</span>] = tmp;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (i == n-<span class="number">1</span>) &#123;</span><br><span class="line">    // 如果i == n-<span class="number">1</span>说明，在<span class="number">0.</span>..n-<span class="number">2</span>之间都没有key，所以返回-<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // 否则，返回i，就是等于key值的元素的下标</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对比两段代码，在字符串 a 很长的时候，比如几万、几十万，你觉得哪段代码运行得更快点呢？答案是代码二，因为两段代码中执行次数最多就是 while 循环那一部分。第二段代码中，我们通过一个哨兵 a[n-1] = key，成功省掉了一个比较语句 i&lt;n，不要小看这一条语句，当累积执行万次、几十万次时，累积的时间就很明显了。</p><p>当然，这只是为了举例说明哨兵的作用，你写代码的时候千万不要写第二段那样的代码，因为可读性太差了。大部分情况下，我们并不需要如此追求极致的性能。</p><h2 id="技巧四：重点留意边界条件处理"><a href="#技巧四：重点留意边界条件处理" class="headerlink" title="技巧四：重点留意边界条件处理"></a>技巧四：重点留意边界条件处理</h2><p>软件开发中，代码在一些边界或者异常情况下，最容易产生 Bug。链表代码也不例外。要实现没有 Bug 的链表代码，一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。</p><p>我经常用来检查链表代码是否正确的边界条件有这样几个：</p><ul><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个结点时，代码是否能正常工作？</li><li>如果链表只包含两个结点时，代码是否能正常工作？</li><li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li></ul><p>当你写完链表代码之后，除了看下你写的代码在正常的情况下能否工作，还要看下在上面我列举的几个边界条件下，代码仍然能否正确工作。如果这些边界条件下都没有问题，那基本上可以认为没有问题了。</p><p>当然，边界条件不止我列举的那些。针对不同的场景，可能还有特定的边界条件，这个需要你自己去思考，不过套路都是一样的。</p><p>实际上，不光光是写链表代码，你在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮！</p><h2 id="技巧五：举例画图，辅助思考"><a href="#技巧五：举例画图，辅助思考" class="headerlink" title="技巧五：举例画图，辅助思考"></a>技巧五：举例画图，辅助思考</h2><p>对于稍微复杂的链表操作，比如前面我们提到的单链表反转，指针一会儿指这，一会儿指那，一会儿就被绕晕了。总感觉脑容量不够，想不清楚。所以这个时候就要使用大招了，<strong>举例法</strong>和<strong>画图法</strong>。</p><p>你可以找一个具体的例子，把它画在纸上，释放一些脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。比如往单链表中插入一个数据这样一个操作，我一般都是把各种情况都举一个例子，画出插入前和插入后的链表变化，如图所示：</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/7%203.jpg" alt=""></p><p>看图写代码，是不是就简单多啦？而且，当我们写完代码之后，也可以举几个例子，画在纸上，照着代码走一遍，很容易就能发现代码中的 Bug。</p><h2 id="技巧六：多写多练，没有捷径"><a href="#技巧六：多写多练，没有捷径" class="headerlink" title="技巧六：多写多练，没有捷径"></a>技巧六：多写多练，没有捷径</h2><p>如果你已经理解并掌握了我前面所讲的方法，但是手写链表代码还是会出现各种各样的错误，也不要着急。因为我最开始学的时候，这种状况也持续了一段时间。</p><p>现在我写这些代码，简直就和“玩儿”一样，其实也没有什么技巧，就是把常见的链表操作都自己多写几遍，出问题就一点一点调试，熟能生巧！</p><p>所以，我精选了 5 个常见的链表操作。你只要把这几个操作都能写熟练，不熟就多写几遍，我保证你之后再也不会害怕写链表代码。</p><ul><li>单链表反转</li><li>链表中环的检测</li><li>两个有序的链表合并</li><li>删除链表倒数第 n 个结点</li><li>求链表的中间结点</li></ul><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>这节我主要和你讲了写出正确链表代码的六个技巧。分别是理解指针或引用的含义、警惕指针丢失和内存泄漏、利用哨兵简化实现难度、重点留意边界条件处理，以及举例画图、辅助思考，还有多写多练。</p><p>我觉得，<strong>写链表代码是最考验逻辑思维能力的</strong>。因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 Bug。链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。所以，这也是很多面试官喜欢让人手写链表代码的原因。所以，这一节讲到的东西，你一定要自己写代码实现一下，才有效果。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>今天我们讲到用哨兵来简化编码实现，你是否还能够想到其他场景，利用哨兵可以大大地简化编码难度？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>04|链表（上）：如何实现LRU缓存淘汰算法?</title>
    <link href="https://chanmoyun.gitee.io/2024/02/26/Data-structure/04.%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/"/>
    <id>https://chanmoyun.gitee.io/2024/02/26/Data-structure/04.%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/</id>
    <published>2024-02-25T16:00:00.000Z</published>
    <updated>2024-02-29T13:01:56.476Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="链表（上）：如何实现LRU缓存淘汰算法"><a href="#链表（上）：如何实现LRU缓存淘汰算法" class="headerlink" title="链表（上）：如何实现LRU缓存淘汰算法?"></a>链表（上）：如何实现LRU缓存淘汰算法?</h1><p>今天我们来聊聊“链表（Linked list）”这个数据结构。学习链表有什么用呢？为了回答这个问题，我们先来讨论一个经典的链表应用场景，那就是 LRU 缓存淘汰算法。</p><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。</p><p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。</p><p>这些策略你不用死记，我打个比方你很容易就明白了。假如说，你买了很多本技术书，但有一天你发现，这些书太多了，太占书房空间了，你要做个大扫除，扔掉一些书籍。那这个时候，你会选择扔掉哪些书呢？对应一下，你的选择标准是不是和上面的三种策略神似呢？</p><p>好了，回到正题，我们今天的开篇问题就是：<strong>如何用链表来实现 LRU 缓存淘汰策略呢？</strong> 带着这个问题，我们开始今天的内容吧！</p><h2 id="五花八门的链表结构"><a href="#五花八门的链表结构" class="headerlink" title="五花八门的链表结构"></a>五花八门的链表结构</h2><p>相比数组，链表是一种稍微复杂一点的数据结构。对于初学者来说，掌握起来也要比数组稍难一些。这两个非常基础、非常常用的数据结构，我们常常将会放到一块儿来比较。所以我们先来看，这两者有什么区别。</p><p>我们先从<strong>底层的存储结构</strong>上来看一看。</p><p>为了直观地对比，我画了一张图。从图中我们看到，数组需要一块<strong>连续的内存空间</strong>来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。</p><p>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/6%201.jpg" alt=""></p><p>链表结构五花八门，今天我重点给你介绍三种最常见的链表结构，它们分别是：单链表、双向链表和循环链表。我们首先来看最简单、最常用的<strong>单链表</strong>。</p><p>我们刚刚讲到，链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“<strong>结点</strong>”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>后继指针</strong> <strong>next</strong>。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/6%202.jpg" alt=""></p><p>从我画的单链表图中，你应该可以发现，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址 NULL</strong>，表示这是链表上最后一个结点。</p><p>与数组一样，链表也支持数据的查找、插入和删除操作。</p><p>我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p><p>为了方便你理解，我画了一张图，从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/6%203.jpg" alt=""></p><p>但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><p>你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第 k 位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。</p><p>好了，单链表我们就简单介绍完了，接着来看另外两个复杂的升级版，<strong>循环链表</strong>和<strong>双向链表</strong>。</p><p><strong>循环链表是一种特殊的单链表。</strong>实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/6%204.jpg" alt=""></p><p>和单链表相比，<strong>循环链表</strong>的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98">约瑟夫问题</a>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><p>单链表和循环链表是不是都不难？接下来我们再来看一个稍微复杂的，在实际的软件开发中，也更加常用的链表结构：<strong>双向链表</strong>。</p><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/6%205.jpg" alt=""></p><p>从我画的图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？</p><p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p><p>你可能会说，我刚讲到单链表的插入、删除操作的时间复杂度已经是 O(1) 了，双向链表还能再怎么高效呢？别着急，刚刚的分析比较偏理论，很多数据结构和算法书籍中都会这么讲，但是这种说法实际上是不准确的，或者说是有先决条件的。我再来带你分析一下链表的两个操作。</p><p>我们先来看<strong>删除操作</strong>。</p><p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul><li>删除结点中“值等于某个给定值”的结点；</li><li>删除给定指针指向的结点。</li></ul><p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。</p><p>尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</p><p>对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。</p><p>但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！</p><p>同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。你可以参照我刚刚讲过的删除操作自己分析一下。</p><p>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><p>现在，你有没有觉得双向链表要比单链表更加高效呢？这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。如果你熟悉 Java 语言，你肯定用过 LinkedHashMap 这个容器。如果你深入研究 LinkedHashMap 的实现原理，就会发现其中就用到了双向链表这种数据结构。</p><p>实际上，这里有一个更加重要的知识点需要你掌握，那就是<strong>用空间换时间</strong>的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p><p>还是开篇缓存的例子。缓存实际上就是利用了空间换时间的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。</p><p>所以我总结一下，对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。你还能想到其他时间换空间或者空间换时间的例子吗？</p><p>了解了循环链表和双向链表，如果把这两种链表整合在一起就是一个新的版本：<strong>双向循环链表</strong>。我想不用我多讲，你应该知道双向循环链表长什么样子了吧？你可以自己试着在纸上画一画。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/6%206.jpg" alt=""></p><h2 id="链表-VS-数组性能大比拼"><a href="#链表-VS-数组性能大比拼" class="headerlink" title="链表 VS 数组性能大比拼"></a>链表 VS 数组性能大比拼</h2><p>通过前面内容的学习，你应该已经知道，数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/6%207.jpg" alt=""></p><p>不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。</p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p><p>你可能会说，我们 Java 中的 ArrayList 容器，也可以支持动态扩容啊？我们上一节课讲过，当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。</p><p>我举一个稍微极端的例子。如果我们用 ArrayList 存储了了 1GB 大小的数据，这个时候已经没有空闲空间了，当我们再插入数据的时候，ArrayList 会申请一个 1.5GB 大小的存储空间，并且把原来那 1GB 的数据拷贝到新申请的空间上。听起来是不是就很耗时？</p><p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p><p>所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>好了，关于链表的知识我们就讲完了。我们现在回过头来看下开篇留给你的思考题。如何基于链表实现 LRU 缓存淘汰算法？</p><p>我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><p>1.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p><p>2.如果此数据没有在缓存链表中，又可以分为两种情况：</p><ul><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ul><p>这样我们就用链表实现了一个 LRU 缓存，是不是很简单？</p><p>现在我们来看下缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。</p><p>实际上，我们可以继续优化这个实现思路，比如引入<strong>散列表</strong>（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。因为要涉及我们还没有讲到的数据结构，所以这个优化方案，我现在就不详细说了，等讲到散列表的时候，我会再拿出来讲。</p><p>除了基于链表的实现思路，实际上还可以用数组来实现 LRU 缓存淘汰策略。如何利用数组实现 LRU 缓存淘汰策略呢？我把这个问题留给你思考。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们讲了一种跟数组“相反”的数据结构，链表。它跟数组一样，也是非常基础、非常常用的数据结构。不过链表要比数组稍微复杂，从普通的单链表衍生出来好几种链表结构，比如双向链表、循环链表、双向循环链表。</p><p>和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。不过，在具体软件开发中，要对数组和链表的各种性能进行对比，综合来选择使用两者中的哪一个。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>如何判断一个字符串是否是回文字符串的问题，我想你应该听过，我们今天的题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>优化算法|02：量子遗传算法(QGA)</title>
    <link href="https://chanmoyun.gitee.io/2024/01/15/Optimization-Algorithm/%E9%87%8F%E5%AD%90%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95(QGA)/"/>
    <id>https://chanmoyun.gitee.io/2024/01/15/Optimization-Algorithm/%E9%87%8F%E5%AD%90%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95(QGA)/</id>
    <published>2024-01-14T16:00:00.000Z</published>
    <updated>2024-01-14T15:57:57.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="量子遗传算法-QGA"><a href="#量子遗传算法-QGA" class="headerlink" title="量子遗传算法(QGA)"></a>量子遗传算法(QGA)</h1><p>    <div id="aplayer-nTJrgFYh" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="72394" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><h2 id="一、量子遗传算法理论基础"><a href="#一、量子遗传算法理论基础" class="headerlink" title="一、量子遗传算法理论基础"></a>一、量子遗传算法理论基础</h2><h3 id="1-1-算法概述"><a href="#1-1-算法概述" class="headerlink" title="1.1 算法概述"></a>1.1 算法概述</h3><p> <strong>量子遗传算法</strong>(Quantum Genetic Algorithm)是量子计算与遗传算法相结合的产物，是一种<strong>概率进化算法</strong>。</p><p> <strong>遗传算法</strong>是处理复杂优化问题的一种方法，其基本思想是<strong>模拟生物进化的优胜劣汰规则与染色体的交换机制</strong>，通过<strong>选择、交叉、变异</strong>三种基本操作寻找最优个体。由于GA不受问题性质、优化准则形式等因素的限制，仅用<strong>目标函数在概率引导下进行全局自适应搜索</strong>，能够处理传统优化方法难以解决的复杂问题，具有极高鲁棒性和广泛适用性，因而得到了广泛应用并成为跨学科研究的热点。但是，若选择、交叉、变异的方式不当，GA会表现出<strong>迭代次数多、收敛速度慢、易陷入局部极值</strong>的现象。</p><p> <strong>量子计算</strong>中采用量子态作为基本的信息单元，利用<strong>量子态的叠加、纠缠和干涉</strong>等特性，通过<strong>量子并行计算</strong>可以解决经典计算中的<strong>NP问题</strong>。1994年Shor提出第一个量子算法，求解了大数质因子分解的经典计算难题，该算法可用于公开密钥系统RSA;1996年Grover提出随机数据库搜索的量子算法，在量子计算机上可实现对未加整理的数据库<strong>√N</strong>量级的加速搜索，量子计算正以其独特的计算性能迅速成为研究的热点。</p><p> <strong>量子遗传算法</strong>就是基于量子计算原理的一种遗传算法。将<strong>量子的态矢量表达引入遗传编码</strong>，<strong>利用量子逻辑门实现染色体的演化</strong>，实现了比常规遗传算法更好的效果。量子遗传算法建立在量子的态矢量表示的基础之上，<strong>将量子比特的几率幅表示应用于染色体的编码，使得一条染色体可以表达多个态的叠加，并利用量子逻辑门实现染色体的更新操作</strong>，从而实现了目标的优化求解。</p><blockquote><p><strong>NP问题：</strong></p><ol><li>在计算复杂度理论中，NP(<strong>Nondeterministic Polynomial Time</strong>)不确定性多项式时间主要用来衡量分类决策问题的复杂度。 NP是一组决策问题，对于这些问题实例来说，如果答案为“是”，那么表示该实例使用确定图灵机可在多项式时间内验证成功。</li><li>NP实际上是由两个阶段组成的，第一阶段包括对解决方案的猜测，该阶段以非确定性方式生成，而第二阶段包括确定性算法，验证猜测是否可以解决问题。也就是说 NP = Nondeterministic + Polynomial。</li></ol><p>鲁棒性：</p><ol><li>英文为Robustness（承受故障和干扰的能力），是许多复杂系统的关键属性。</li><li>鲁棒性”，是指控制系统在一定(结构，大小)的参数摄动下，维持其它某些性能的特性。</li><li>“稳定性”，是指控制系统在使它偏离平衡状态的扰动作用消失后，返回原来平衡状态的能力。</li></ol></blockquote><h3 id="1-2-量子比特编码"><a href="#1-2-量子比特编码" class="headerlink" title="1.2 量子比特编码"></a>1.2 量子比特编码</h3><p> 在量子计算机中，充当信息存储单元的物理介质是一个<strong>双态量子系统</strong>，称为<strong>量子比特</strong>。量子比特与经典位不同就在于它可以同时处在两个量子态的叠加态中，比如：</p><script type="math/tex; mode=display">\left| \varphi \right> =\alpha \left| 0 \right> \beta \left| 1 \right></script><p>其中$\text{（}\alpha \text{，}\beta \text{）}$是两个量子比特概率幅(量子幅，描述粒子的量子行为的复函数，满足 $\left| \alpha \right|^2+\left| \beta \right|^2=1$。</p><p>其中$\left| 0 \right&gt;$和$\left| 1 \right&gt;$分别表示自旋向下态和自旋向上态，所以一个量子比特可同时包含0和1的信息。</p><p>在量子遗传算法中，采用量子比特存储和表达一个基因。该基因可以为“0”态或“1”态，或它们的任意叠加态。即该基因所表达的不再是某一确定的信息，而是包含所有可能的信息，对该基因的任一操作也会同时作用于所有可能的信息。</p><p> 采用量子比特编码使得一个染色体可以同时表达多个态的叠加，使得量子遗传算法比经典遗传算法拥有更好的多样性特征。采用量子比特编码也可以获得较好的收敛性，$\left| \alpha \right|^2\text{或}\left| \beta \right|^2$趋于0或1，量子比特编码的染色体将收敛到一个单一态。</p><h3 id="1-3-量子门更新"><a href="#1-3-量子门更新" class="headerlink" title="1.3 量子门更新"></a>1.3 量子门更新</h3><p>量子遗传算法中的量子门更新的作用可理解为遗传算法中的变异或交叉操作，量子门作为演化操作的执行机构，可根据具体问题进行选择，目前已有的量子门有很多种，根据量子遗传算法的计算特点，选择<strong>量子旋转门$RY\left( \theta \right)$</strong>较为合适。量子旋转门的调整操作为：</p><script type="math/tex; mode=display">U\left({\theta }_{i} \right) =\left[ \begin{matrix}    \cos \left({\theta }_{i} \right)&        -\sin \left( {\theta }_{i} \right)\\    \sin \left( {\theta }_{i} \right)&        \cos \left( {\theta }_{i} \right)\\\end{matrix} \right]</script><p>其更新过程如下：</p><script type="math/tex; mode=display">\left[ \begin{array}{c}    {\alpha }_{i}^{'}\\    {\beta }_{i}^{'}\\\end{array} \right] ={U}\left( {\theta }_{i} \right) \left[ \begin{array}{c}    {\alpha }_{i}\\    {\beta }_{i}\\\end{array} \right] =\left[ \begin{matrix}    \cos \left({\theta }_{i} \right)&        -\sin \left({\theta }_{i} \right)\\    \sin \left( {\theta }_{i} \right)&        \cos \left( {\theta }_{i} \right)\\\end{matrix} \right] \left[ \begin{array}{c}    {\alpha }_{i}\\    {\beta }_{i}\\\end{array} \right]</script><p>$\left( {\alpha }_{i},{\beta }_{\boldsymbol{i}} \right) ^{T}$和$\left( {\alpha }_{i}^{‘},{\beta }_{i}^{‘} \right) ^{T}$代表染色体第i个量子比特旋转门更新前后的概率幅； $\theta _i\ $为旋转角，它的大小和符号由事先设计的调整策略确定。</p><p>于是可以得出：</p><script type="math/tex; mode=display">\left\{ \begin{array}{l}    \alpha _{i}^{'}=\alpha _i\cos \left( \theta _i \right) -\beta _i\sin \left( \theta _i \right)\\    \beta _{i}^{'}=\alpha _i\sin \left( \theta _i \right) +\beta _i\cos \left( \theta _i \right)\\\end{array} \right.</script><p>所以有：</p><script type="math/tex; mode=display">\left| \alpha _{i}^{'} \right|^2+\left| \beta _{i}^{'} \right|^2=\left[ \alpha _i\cos \left( \theta _i \right) -\beta _i\sin \left( \theta _i \right) \right] ^2+\left[ \alpha _i\sin \left( \theta _i \right) +\beta _i\cos \left( \theta _i \right) \right] ^2 \\=\left| \alpha _i \right|^2+\left| \beta _i \right|^2=1</script><p>可以看得出变换后的值仍为1。</p><h2 id="二、遗传算法原理分析"><a href="#二、遗传算法原理分析" class="headerlink" title="二、遗传算法原理分析"></a>二、遗传算法原理分析</h2><h3 id="2-1-非线性规划"><a href="#2-1-非线性规划" class="headerlink" title="2.1 非线性规划"></a>2.1 非线性规划</h3><p>非线性规划研究一个n元实函数在一组等式或不等式的约束条件下的极值问题，20世纪80年代以来，随着计算机技术的快速发展，非线性规划方法取得了长足进步，在信赖域法、稀疏拟牛顿法、并行计算、内点法和有限储存法等领域取得了丰硕的研究成果。</p><p> 函数fmincon是MATLAB优化工具箱中求解非线性规划问题的函数，它从一个预估值出发，搜索约束条件下非线性多元函数的最小值。函数fmincon的约束条件为：</p><script type="math/tex; mode=display">\min f\left( x \right) \rightarrow \left\{ \begin{array}{l}    c\left( x \right) \le 0\\    ceq\left( x \right) =0\\    A\cdot x\le b\\    Aeq\cdot x=beq\\    1b\le x\le ub\\\end{array} \right.</script><p>其中，x、b、beq、Ib和ub是矢量；A和Aeq为矩阵；c(x)和ceq(x)返回矢量的函数；f(x)、c (x)和ceq(x)是非线性函数。lb和ub分别为x的下界和上界。当函数输入参数不包括A、b、Aeq、beq时，默认 A=0、b=0、Aeq=[]、beq=[]。x0为x的初设值。</p><p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=fmincon(fun,x0,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure></p><h3 id="2-2-遗传算法基础理论"><a href="#2-2-遗传算法基础理论" class="headerlink" title="2.2 遗传算法基础理论"></a>2.2 遗传算法基础理论</h3><h4 id="详见文章——遗传算法-GA"><a href="#详见文章——遗传算法-GA" class="headerlink" title="详见文章——遗传算法(GA)"></a>详见文章——遗传算法(GA)</h4><h2 id="三、案例应用分析"><a href="#三、案例应用分析" class="headerlink" title="三、案例应用分析"></a>三、案例应用分析</h2><h3 id="3-1-问题描述"><a href="#3-1-问题描述" class="headerlink" title="3.1 问题描述"></a>3.1 问题描述</h3><p>对于复杂二元函数求最值。</p><script type="math/tex; mode=display">\max f\left( x,y \right) =x\sin \left( 4\pi x \right) +y\sin \left( 20\pi y \right) \\\\\left\{ \begin{array}{l}    -3.0\le x\le 12.1\\    4.1\le y\le 5.8\\\end{array} \right.</script><p>该函数图像程序为：</p><p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">12.1</span>, <span class="number">200</span>);</span><br><span class="line">y = <span class="built_in">linspace</span>(<span class="number">4.1</span>, <span class="number">5.8</span>, <span class="number">50</span>);</span><br><span class="line">[x, y] = <span class="built_in">meshgrid</span>(x,y);</span><br><span class="line">f = x.*<span class="built_in">sin</span>(<span class="number">4</span>*<span class="built_in">pi</span>*x)+y.*<span class="built_in">sin</span>(<span class="number">20</span>*<span class="built_in">pi</span>*y);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">mesh(x,y,f);</span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">zlabel(<span class="string">&#x27;f(x,y)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;函数图像&#x27;</span>)</span><br></pre></td></tr></table></figure></p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/xyfun1.jpg" alt=""></p><p>从图中可以看出，该非线性函数在给定范围内分布着许多局部极值，通常的寻优算法极易陷入局部极值或在各局部极值间振荡，比较适用于验证量子遗传算法的性能。</p><h3 id="3-2-解题步骤"><a href="#3-2-解题步骤" class="headerlink" title="3.2 解题步骤"></a>3.2 解题步骤</h3><h4 id="3-2-1-算法步骤及流程"><a href="#3-2-1-算法步骤及流程" class="headerlink" title="3.2.1 算法步骤及流程"></a>3.2.1 算法步骤及流程</h4><blockquote><ol><li>初始化种群$Q\left( t_0 \right)$,随机生成n个以量子比特为编码的染色体；</li><li>对初始种群$Q\left( t_0 \right)$中的每个个体进行一次测量，得到对应的确定解P(t0);</li><li>对各确定解进行适应度评估；</li><li>记录最优个体和对应的适应度；</li><li>判断计算过程是否可以结束，若满足结束条件则退出，否则继续计算；</li><li>对种群$Q\left( t \right)$中的每个个体实施一次测量，得到相应的确定解；</li><li>对各确定解进行适应度评估；</li><li>利用量子旋转门$U\left(t\right)$对个体实施调整，得到新的种群$Q\left( t+1 \right)$;</li><li>记录最优个体和对应的适应度；</li><li>将迭代次数t加1,返回步骤(5)。</li></ol></blockquote><p>对应流程图如下所示：</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/QGA.png" alt=""></p><p>算法步骤1是初始化种群$Q(t_0)$，种群中全部染色体的所有基因$<br>\left( \alpha _{i}^{t},\beta _{i}^{t} \right)<br>$全部被初始化为$<br>\left( \frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}} \right)<br>$，表明一个染色体所表达的全部可能状态的等概率叠：</p><script type="math/tex; mode=display">\left| \psi _{q_{j}^{t}} \right> =\sum{_{k=1}^{2m}}\frac{1}{\sqrt{2}^m} \left| S_k \right></script><p>其中$S_k$为该染色体的第k种状态，表现形式为一长度为m的二进制串$(x_1,x_2,…,x_m)$，$x_i$的值为0或1。</p><p>算法的步骤(2)是对初始种群中的个体进行一次测量，以获得一组确定的解 $P(t) = { p_{1}^{t},p_{2}^{t},…,p_{j}^{t},…,p_{n}^{t} } $ ，其中， $p_{j}^{t}$为第t代种群中第j个解（第j个个体的测量值），表现形式为长度为m的二进制串，其中每一位为0或1，是根据量子比特的概率$（ |\alpha|^2 $或$ |\beta|^2 ，i=1,2，…，m）$选择得到的。测量过程为，随机产生一个[0,1]区间的数，若它大于概率幅的平方，则测量结果取值1，否则取值0。然后，对这一组解进行适应度评估，记录下最佳适应度个体作为下一步演化的目标值。</p><p>  随后，算法进入循环迭代阶段，随着迭代的进行，种群的解逐渐向最优解收敛。在每一次迭代中，首先对种群进行测量，以获得一组确定解 $P(t)$ ，然后计算每个解的适应度值，再根据当前的演化目标和事先确定的调整策略，利用量子旋转门对种群中的个体进行调整，获得更新后的种群，记录下当前的最优解，并与当前的目标值进行比较，如果大于当前目标值，则以新的最优解作为下一次迭代的目标值，否则保持当前的目标值不变。</p><h4 id="3-2-2-量子遗传算法实现"><a href="#3-2-2-量子遗传算法实现" class="headerlink" title="3.2.2 量子遗传算法实现"></a>3.2.2 量子遗传算法实现</h4><h5 id="3-2-2-1-量子比特编码"><a href="#3-2-2-1-量子比特编码" class="headerlink" title="3.2.2.1 量子比特编码"></a>3.2.2.1 量子比特编码</h5><p>采用遗传算法中的二进制编码，对存在多态的问题进行量子比特编码，如两态用一个量子比特进行编码，四态用两个量子比特进行编码。该方法的优点是通用性好，且实现简单。采用多量子比特编码m个参数的基因如下：</p><script type="math/tex; mode=display">q_{j}^{t}=\left( \begin{array}{c}    \alpha _{11}^{t}\\    \beta _{11}^{t}\\\end{array}\left| \begin{array}{c}    \alpha _{12}^{t}\\    \beta _{12}^{t}\\\end{array}\left| \begin{array}{c}    ...\\    ...\\\end{array} \right|\begin{array}{c}    \alpha _{1k}^{t}\\    \beta _{1k}^{t}\\\end{array}\left| \begin{array}{c}    \alpha _{21}^{t}\\    \beta _{21}^{t}\\\end{array} \right. \right. \left| \left. \begin{array}{c}    ...\\    ...\\\end{array}\left| \begin{array}{c}    \alpha _{2k}^{t}\\    \beta _{2k}^{t}\\\end{array} \right. \right|\begin{array}{c}    \alpha _{m1}^{t}\\    \beta _{m1}^{t}\\\end{array}\left| \begin{array}{c}    ...\\    ...\\\end{array}\left| \begin{array}{c}    \alpha _{mk}^{t}\\    \beta _{mk}^{t}\\\end{array} \right. \right. \right. \right)</script><p>其中，$q_j^t$代表第t代、第j个个体的染色体；k为拜尼马每一个基因的量子比特数；m为染色体基因个数。将种群各个个体的量子比特编码$(\alpha,\beta)$都初始化为$( \frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}) $，这意味着一个染色体所表达的全部可能状态是等概率的。</p><h5 id="3-2-2-2-量子旋转门"><a href="#3-2-2-2-量子旋转门" class="headerlink" title="3.2.2.2 量子旋转门"></a>3.2.2.2 量子旋转门</h5><p>量子遗传算法中，旋转门是最终实现演化操作的执行机构，这里使用一种通用的、与问题无关的调整策略，如下表所示。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/XZMCL.png" alt=""></p><blockquote><ul><li>$x_i$为当前染色体的第i位； </li><li>$best_i$为当前的最优染色体的第i位； </li><li>$f(x)$为适应度函数； </li><li>$s(\alpha_i,\beta_i)$为旋转角方向；$\varDelta \theta _i$为旋转角度大小，其值根据表中所列的选择策略确定。</li></ul></blockquote><p>该调整策略是将个体 $q_t^j$ 当前的测量值的适应度 $f(x)$ 与该种群当前最优个体的适应度值 $f(best_i)$ 进行比较，如果 $f(x)&gt;f(best_i)$ ，则调整 $q_t^j$  中相应位量子比特，使得几率幅对 $(\alpha_i,\beta_i)$ 向着有利于 $x_i$ 出现的方向演化；反之，如果 $f(x)&lt;f(best_i)$ ，则调整 $q_t^j $中相应位量子比特，使得几率幅对 $(\alpha_i,\beta_i)$向着有利于$best$出现的方向演化。 </p><h5 id="3-2-2-3-程序实现"><a href="#3-2-2-3-程序实现" class="headerlink" title="3.2.2.3 程序实现"></a>3.2.2.3 程序实现</h5><h6 id="种群初始化函数InitPop"><a href="#种群初始化函数InitPop" class="headerlink" title="种群初始化函数InitPop"></a>种群初始化函数InitPop</h6><p>初始化种群，随机生成n个以量子比特为编码的染色体，得到初始种群的量子比特编码矩阵chrom。</p><p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chrom</span>=<span class="title">InitPop</span><span class="params">(M,N)</span></span></span><br><span class="line"><span class="comment">%% 初始化种群-量子比特编码</span></span><br><span class="line"><span class="comment">% M:为种群大小×2，(α和β)</span></span><br><span class="line"><span class="comment">% N:为量子比特编码长度</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:M</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:N</span><br><span class="line">        chrom(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="number">1</span>/<span class="built_in">sqrt</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h6 id="测量函数collapse"><a href="#测量函数collapse" class="headerlink" title="测量函数collapse"></a>测量函数collapse</h6><p>对初始种群每个个体进行一次测量，得到二进制编码。</p><p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binary</span>=<span class="title">collapse</span><span class="params">(chrom)</span></span></span><br><span class="line"><span class="comment">%% 对种群实施一次测量 得到二进制编码</span></span><br><span class="line"><span class="comment">% 输入chrom ：为量子比特编码</span></span><br><span class="line"><span class="comment">% 输出binary：二进制编码</span></span><br><span class="line">[M,N]=<span class="built_in">size</span>(chrom);  <span class="comment">%得到种群大小 和编码长度</span></span><br><span class="line">M=M/<span class="number">2</span>;  <span class="comment">% 种群大小</span></span><br><span class="line">binary=<span class="built_in">zeros</span>(M,N);  <span class="comment">%二进制编码大小初始化</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:M</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:N</span><br><span class="line">        pick=<span class="built_in">rand</span>;  <span class="comment">%产生【0,1】随机数</span></span><br><span class="line">        <span class="keyword">if</span> pick&gt;(chrom(<span class="number">2.</span>*<span class="built_in">i</span><span class="number">-1</span>,<span class="built_in">j</span>)^<span class="number">2</span>)    <span class="comment">% 随机数大于α的平方</span></span><br><span class="line">            binary(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            binary(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h6 id="量子旋转门函数Qgate"><a href="#量子旋转门函数Qgate" class="headerlink" title="量子旋转门函数Qgate"></a>量子旋转门函数Qgate</h6><p>旋转门是最终实现演化操作的执行机构，参考旋转门调整策略表。</p><p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chrom</span>=<span class="title">Qgate</span><span class="params">(chrom,fitness,best,binary)</span></span></span><br><span class="line"><span class="comment">%% 量子旋转门调整策略</span></span><br><span class="line"><span class="comment">% 输入  chrom：更新前的量子比特编码</span></span><br><span class="line"><span class="comment">%     fitness：适应度值</span></span><br><span class="line"><span class="comment">%        best：当前种群中最优个体</span></span><br><span class="line"><span class="comment">%      binary：二进制编码</span></span><br><span class="line"><span class="comment">% 输出  chrom：更新后的量子比特编码</span></span><br><span class="line">sizepop=<span class="built_in">size</span>(chrom,<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">lenchrom=<span class="built_in">size</span>(binary,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:sizepop</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:lenchrom</span><br><span class="line">        A=chrom(<span class="number">2</span>*<span class="built_in">i</span><span class="number">-1</span>,<span class="built_in">j</span>);   <span class="comment">% α</span></span><br><span class="line">        B=chrom(<span class="number">2</span>*<span class="built_in">i</span>,<span class="built_in">j</span>);     <span class="comment">% β</span></span><br><span class="line">        x=binary(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">        b=best.binary(<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">if</span> ((x==<span class="number">0</span>)&amp;(b==<span class="number">0</span>))||((x==<span class="number">1</span>)&amp;(b==<span class="number">1</span>))</span><br><span class="line">            delta=<span class="number">0</span>;                  <span class="comment">% delta为旋转角的大小</span></span><br><span class="line">            s=<span class="number">0</span>;                        <span class="comment">% s为旋转角的符号，即旋转方向</span></span><br><span class="line">        <span class="keyword">elseif</span> (x==<span class="number">0</span>)&amp;(b==<span class="number">1</span>)&amp;(fitness(<span class="built_in">i</span>)&lt;best.fitness)</span><br><span class="line">            delta=<span class="number">0.01</span>*<span class="built_in">pi</span>;</span><br><span class="line">            <span class="keyword">if</span> A*B&gt;<span class="number">0</span></span><br><span class="line">                s=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">elseif</span> A*B&lt;<span class="number">0</span></span><br><span class="line">                s=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">elseif</span> A==<span class="number">0</span></span><br><span class="line">                s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">elseif</span> B==<span class="number">0</span></span><br><span class="line">                s=<span class="built_in">sign</span>(<span class="built_in">randn</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">elseif</span> (x==<span class="number">0</span>)&amp;(b==<span class="number">1</span>)&amp;(fitness(<span class="built_in">i</span>)&gt;=best.fitness)</span><br><span class="line">            delta=<span class="number">0.01</span>*<span class="built_in">pi</span>;</span><br><span class="line">            <span class="keyword">if</span> A*B&gt;<span class="number">0</span></span><br><span class="line">                s=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">elseif</span> A*B&lt;<span class="number">0</span></span><br><span class="line">                s=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">elseif</span> A==<span class="number">0</span></span><br><span class="line">                s=<span class="built_in">sign</span>(<span class="built_in">randn</span>);</span><br><span class="line">            <span class="keyword">elseif</span> B==<span class="number">0</span></span><br><span class="line">                s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">elseif</span> (x==<span class="number">1</span>)&amp;(b==<span class="number">0</span>)&amp;(fitness(<span class="built_in">i</span>)&lt;best.fitness)</span><br><span class="line">            delta=<span class="number">0.01</span>*<span class="built_in">pi</span>;</span><br><span class="line">            <span class="keyword">if</span> A*B&gt;<span class="number">0</span></span><br><span class="line">                s=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">elseif</span> A*B&lt;<span class="number">0</span></span><br><span class="line">                s=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">elseif</span> A==<span class="number">0</span></span><br><span class="line">                s=<span class="built_in">sign</span>(<span class="built_in">randn</span>);</span><br><span class="line">            <span class="keyword">elseif</span> B==<span class="number">0</span></span><br><span class="line">                s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">elseif</span> (x==<span class="number">1</span>)&amp;(b==<span class="number">0</span>)&amp;(fitness(<span class="built_in">i</span>)&gt;=best.fitness)</span><br><span class="line">            delta=<span class="number">0.01</span>*<span class="built_in">pi</span>;</span><br><span class="line">            <span class="keyword">if</span> A*B&gt;<span class="number">0</span></span><br><span class="line">                s=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">elseif</span> A*B&lt;<span class="number">0</span></span><br><span class="line">                s=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">elseif</span> A==<span class="number">0</span></span><br><span class="line">                s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">elseif</span> B==<span class="number">0</span></span><br><span class="line">                s=<span class="built_in">sign</span>(<span class="built_in">randn</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        e=s*delta;       <span class="comment">% e为旋转角</span></span><br><span class="line">        U=[<span class="built_in">cos</span>(e) -<span class="built_in">sin</span>(e);<span class="built_in">sin</span>(e) <span class="built_in">cos</span>(e)];      <span class="comment">% 量子旋转门</span></span><br><span class="line">        y=U*[A B]&#x27;;        <span class="comment">% y为更新后的量子位</span></span><br><span class="line">        chrom(<span class="number">2</span>*<span class="built_in">i</span><span class="number">-1</span>,<span class="built_in">j</span>)=y(<span class="number">1</span>);</span><br><span class="line">        chrom(<span class="number">2</span>*<span class="built_in">i</span>,<span class="built_in">j</span>)=y(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h6 id="适应度函数FitnessFunction-主"><a href="#适应度函数FitnessFunction-主" class="headerlink" title="适应度函数FitnessFunction(主)"></a>适应度函数FitnessFunction(主)</h6><p>这里以求解最大值问题为例进行说明，如果是求解最小值问题，可以转变成求最大值问题(加个负号即可),目标值越大的个体，其适应度值也应该越大，所以可以直接将所优化的目标 函数作为适应度函数。适应度主函数FitnessFunction的代码：</p><p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[fitness,X]</span>=<span class="title">FitnessFunction</span><span class="params">(binary,lenchrom)</span></span></span><br><span class="line"><span class="comment">%% 适应度函数</span></span><br><span class="line"><span class="comment">% 输入  binary：二进制编码</span></span><br><span class="line"><span class="comment">%     lenchrom：各变量的二进制位数</span></span><br><span class="line"><span class="comment">% 输出 fitness：适应度</span></span><br><span class="line"><span class="comment">%            X：十进制数（待优化参数）</span></span><br><span class="line">sizepop=<span class="built_in">size</span>(binary,<span class="number">1</span>);</span><br><span class="line">fitness=<span class="built_in">zeros</span>(<span class="number">1</span>,sizepop);</span><br><span class="line">num=<span class="built_in">size</span>(lenchrom,<span class="number">2</span>);</span><br><span class="line">X=<span class="built_in">zeros</span>(sizepop,num);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:sizepop</span><br><span class="line">    [fitness(<span class="built_in">i</span>),X(<span class="built_in">i</span>,:)]=Objfunction(binary(<span class="built_in">i</span>,:),lenchrom);         <span class="comment">% 使用目标函数计算适应度</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p> 其中，函数Objfunction是待优化的目标函数，这里以案例函数为例进行说明。函数Objfunction的代码：</p><p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[Y,X]</span>=<span class="title">Objfunction</span><span class="params">(x,lenchrom)</span></span></span><br><span class="line"><span class="comment">%% 目标函数</span></span><br><span class="line"><span class="comment">% 输入     x：二进制编码</span></span><br><span class="line"><span class="comment">%   lenchrom：各变量的二进制位数</span></span><br><span class="line"><span class="comment">% 输出     Y：目标值</span></span><br><span class="line"><span class="comment">%          X：十进制数</span></span><br><span class="line">bound=[<span class="number">-3.0</span> <span class="number">12.1</span>;<span class="number">4.1</span> <span class="number">5.8</span>];   <span class="comment">% 函数自变量的范围</span></span><br><span class="line"><span class="comment">%% 将binary数组转化成十进制数组</span></span><br><span class="line">X=bin2decFun(x,lenchrom,bound);</span><br><span class="line"><span class="comment">%% 计算适应度-函数值</span></span><br><span class="line">Y=<span class="built_in">sin</span>(<span class="number">4</span>*<span class="built_in">pi</span>*X(<span class="number">1</span>))*X(<span class="number">1</span>)+<span class="built_in">sin</span>(<span class="number">20</span>*<span class="built_in">pi</span>*X(<span class="number">2</span>))*X(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>函数bin2decFun是将二进制编码转换成十进制数，其代码如下：</p><p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span>=<span class="title">bin2decFun</span><span class="params">(x,lenchrom,bound)</span></span></span><br><span class="line"><span class="comment">%% 二进制转化成十进制</span></span><br><span class="line"><span class="comment">% 输入      x：二进制编码</span></span><br><span class="line"><span class="comment">%    lenchrom：各变量的二进制位数</span></span><br><span class="line"><span class="comment">%       bound：各变量的范围</span></span><br><span class="line"><span class="comment">% 输出      X：十进制数</span></span><br><span class="line">M=<span class="built_in">length</span>(lenchrom);</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line">X=<span class="built_in">zeros</span>(<span class="number">1</span>,M);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:M</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=lenchrom(<span class="built_in">i</span>)<span class="number">-1</span>:<span class="number">-1</span>:<span class="number">0</span></span><br><span class="line">        X(<span class="built_in">i</span>)=X(<span class="built_in">i</span>)+x(n).*<span class="number">2.</span>^<span class="built_in">j</span>;</span><br><span class="line">        n=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">X=bound(:,<span class="number">1</span>)&#x27;+X./(<span class="number">2.</span>^lenchrom<span class="number">-1</span>).*(bound(:,<span class="number">2</span>)-bound(:,<span class="number">1</span>))&#x27;; </span><br></pre></td></tr></table></figure></p><h6 id="量子遗传算法主函数main"><a href="#量子遗传算法主函数main" class="headerlink" title="量子遗传算法主函数main"></a>量子遗传算法主函数main</h6><p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line"><span class="comment">%----------------参数设置-----------------------</span></span><br><span class="line">MAXGEN=<span class="number">200</span>;                        <span class="comment">% 最大遗传代数</span></span><br><span class="line">sizepop=<span class="number">40</span>;                        <span class="comment">% 种群大小</span></span><br><span class="line">lenchrom=[<span class="number">20</span> <span class="number">20</span>];          <span class="comment">% 每个变量的二进制长度</span></span><br><span class="line">trace=<span class="built_in">zeros</span>(<span class="number">1</span>,MAXGEN);</span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------      </span></span><br><span class="line">best=struct(<span class="string">&#x27;fitness&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;X&#x27;</span>,[],<span class="string">&#x27;binary&#x27;</span>,[],<span class="string">&#x27;chrom&#x27;</span>,[]);   <span class="comment">% 最佳个体 记录其适应度值、十进制值、二进制编码、量子比特编码</span></span><br><span class="line"><span class="comment">%% 初始化种群</span></span><br><span class="line">chrom=InitPop(sizepop*<span class="number">2</span>,sum(lenchrom));</span><br><span class="line"><span class="comment">%% 对种群实施一次测量 得到二进制编码</span></span><br><span class="line">binary=collapse(chrom); </span><br><span class="line"><span class="comment">%% 求种群个体的适应度值，和对应的十进制值</span></span><br><span class="line">[fitness,X]=FitnessFunction(binary,lenchrom);         <span class="comment">% 使用目标函数计算适应度</span></span><br><span class="line"><span class="comment">%% 记录最佳个体到best</span></span><br><span class="line">[best.fitness bestindex]=<span class="built_in">max</span>(fitness);     <span class="comment">% 找出最大值</span></span><br><span class="line">best.binary=binary(bestindex,:);</span><br><span class="line">best.chrom=chrom([<span class="number">2</span>*bestindex<span class="number">-1</span>:<span class="number">2</span>*bestindex],:);</span><br><span class="line">best.X=X(bestindex,:);</span><br><span class="line">trace(<span class="number">1</span>)=best.fitness;</span><br><span class="line">fprintf(<span class="string">&#x27;%d\n&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">%% 进化</span></span><br><span class="line"><span class="keyword">for</span> gen=<span class="number">2</span>:MAXGEN</span><br><span class="line">    fprintf(<span class="string">&#x27;%d\n&#x27;</span>,gen)  <span class="comment">%提示进化代数</span></span><br><span class="line">    <span class="comment">%% 对种群实施一次测量</span></span><br><span class="line">    binary=collapse(chrom);</span><br><span class="line">    <span class="comment">%% 计算适应度</span></span><br><span class="line">    [fitness,X]=FitnessFunction(binary,lenchrom);</span><br><span class="line">    <span class="comment">%% 量子旋转门</span></span><br><span class="line">    chrom=Qgate(chrom,fitness,best,binary);</span><br><span class="line">    [newbestfitness,newbestindex]=<span class="built_in">max</span>(fitness);    <span class="comment">% 找到最佳值</span></span><br><span class="line">    <span class="comment">% 记录最佳个体到best</span></span><br><span class="line">    <span class="keyword">if</span> newbestfitness&gt;best.fitness</span><br><span class="line">        best.fitness=newbestfitness;</span><br><span class="line">        best.binary=binary(newbestindex,:);</span><br><span class="line">        best.chrom=chrom([<span class="number">2</span>*newbestindex<span class="number">-1</span>:<span class="number">2</span>*newbestindex],:);</span><br><span class="line">        best.X=X(newbestindex,:);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    trace(gen)=best.fitness;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%% 画进化曲线</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:MAXGEN,trace);</span><br><span class="line">title(<span class="string">&#x27;进化过程&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;进化代数&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;每代的最佳适应度&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">%% 显示优化结果</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;最优解X：&#x27;</span>,num2str(best.X)])</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;最大值Y:&#x27;</span>,num2str(best.fitness)]);</span><br><span class="line"> </span><br></pre></td></tr></table></figure></p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/Qga%E8%BF%9B%E5%8C%96%E8%BF%87%E7%A8%8B.jpg" alt=""></p><p>以上代码根据案例二元函数求最值编写，具体运用可以根据自己的实际问题修改函数Objfunction(待优化的问题也并不局限在函数优化，可以是一个复杂的运算过程),然后修改下主函数中的相应变量设置即可。</p><h2 id="四、量子遗传算法拓展思路"><a href="#四、量子遗传算法拓展思路" class="headerlink" title="四、量子遗传算法拓展思路"></a>四、量子遗传算法拓展思路</h2><p>以上介绍和运用的是基础量子遗传算法，该算法可针对相关需求进行改进。</p><blockquote><ol><li>前面使用的是固定旋转角策略，可以根据进化进程动态调整量子门的旋转角大小。算法运行初期设置较大的旋转角，随着进化代数的增加逐渐减小旋转角。调整策略是对个体$q_j^t$ 进行测量，评估其适应度$ f(x_j)^t $，与保留的最优个体的适应度值 $f(best)$进行比较，根据比较结果调整$q_j^t$  中相应位量子比特，使得$(\alpha,\beta)$朝着有利于最优确定解的方向进化。</li><li>加入量子交叉操作。量子遗传算法中最能体现个体结构信息的是其进化目标，即个体当前最优确定解以及对应的适应度值，因此，可以考虑互换个体的进化目标以实现个体间信息的互换，从而实现量子交叉的目的。其基本操作就是在个体之间暂时交换最优确定解和最优适应度值，个体接受交叉操作后，它的进化方向将受到其他个体的影响，从而获取新的进化信息。</li><li>加入量子变异操作。量子变异的作用是轻微地打乱某个个体当前的进化方向，以防止该个体的进化陷入局部最优。量子变异通过操作染色体编码实现，互换量子比特概率幅 $(\alpha,\beta)$的值，可将个体的进化方向彻底反转。量子变异操作采用单点变异和多点变异相结合的方式，以增强种群中基因的多样性。</li><li>加入量子灾变。当算法经历数代稳定后，最优个体保持稳定时，算法可能陷入了局部最优解，此时采取量子灾变操作，可使其摆脱局部最优解。具体方法是，将种群中部分个体施加大的扰动，重新随机生成部分个体。</li></ol></blockquote><h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><ol><li><strong>MATLAB智能算法30个案例分析_(史峰，王辉编著)——主</strong></li><li><strong>智能优化算法及其MATLAB实例（第2版）_(包子阳__等)</strong></li><li><strong>精通MATLAB最优化计算（第2版）</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="优化算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-优化算法 -量子计算" scheme="https://chanmoyun.gitee.io/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>优化算法|01：遗传算法(GA)</title>
    <link href="https://chanmoyun.gitee.io/2024/01/01/Optimization-Algorithm/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95(GA)/"/>
    <id>https://chanmoyun.gitee.io/2024/01/01/Optimization-Algorithm/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95(GA)/</id>
    <published>2023-12-31T16:00:00.000Z</published>
    <updated>2024-01-12T09:22:36.533Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="遗传算法-GA"><a href="#遗传算法-GA" class="headerlink" title="遗传算法(GA)"></a>遗传算法(GA)</h1><p>    <div id="aplayer-MKzMGknT" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="2090583673" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><h2 id="一、遗传算法理论基础"><a href="#一、遗传算法理论基础" class="headerlink" title="一、遗传算法理论基础"></a>一、遗传算法理论基础</h2><h3 id="1-1-算法概述"><a href="#1-1-算法概述" class="headerlink" title="1.1 算法概述"></a>1.1 算法概述</h3><p>遗传算法(genetic algorithm, GA)是一种通过模拟自然选择机制,形成扩大搜索范围并验证寻优的进化算法。遗传算法(GA)的特点在于,将问题参数转化为 染色体编码,通过一系列随机操作(包括选择、交叉、变异<u>和逆变</u>)对染色体信息进行迭代修改,最终生成适应于优化目标的个体,即符合环境要求的染色体。整个进化过程并不完全随机,父代的信息会促使子代向适应环境的方向逐步进化。</p><p>遗传算法的优点主要体现在扩大了解的搜索空间，即使适应度函数不完全连续， 也大概率能找到搜索范围中的全局最优解，从而避免了陷入局部最优解无法跳出 的问题。</p><h3 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h3><p><strong>术语：</strong></p><p><img src="D:\Desktop\BaiduSyncdisk\Myblogs\Pic\2024-1\24-01-12_16-17-59.png" alt=""></p><p><strong>群体和个体：</strong>群体是生物进化过程中的一个集团，表示可行解集；<br>个体是组成群体的单个生物体，表示可行解。</p><p><strong>遗传编码：</strong>遗传编码将优化变量转化为基因的组合表示形式，优化变量的编码机制有二进制编码、十进制编码（实数编码）等。</p><p><strong>二进制编码原理和实现：</strong>例如，求实数区间[0，4]上函数 $f(x)$ 的最大值，传统的方法是调整自变量 $x$ 的值，直到获得函数最大值；遗传算法则不对参数本身进行调整，而是首先将参数进行编码，形成位串，再对位串进行进化操作。我们由长度为6的位串表示变量 x ，即从 “000000”到“111111”，并将取值映射到实数区间[0，4]内。从整数上来看，6位长度的二进制编码位串可以表示0～63，对应[0，4]的区间，每个相邻整数值之间的阶跃值为4/63≈0.0635，就是<strong>编码精度</strong>。一般，编码精度越高，解越优良；但同时，遗传操作所需的计算量也更大，耗时将更长，因此编码位数需要适当选择。</p><p><strong>适用度：</strong>适应度即生物群体中个体适应生存环境的能力。在遗传算法中，用来评价个体优劣的数学函数，称为个体的适应度函数。遗传算法在进化搜索中基本上不用外部信息，仅以适应度函数为依据。它的目标函数不受连续可微的约束，且定义域可以为任意集合。对适应度函数的唯一要求是，针对输入可计算出能进行比较的结果。构造方法主要有：目标函数映射成适应度函数，基于序的适应度函数等。</p><p><strong>遗传操作如下：</strong></p><blockquote><p><strong>1.选择</strong></p><p>确定重组或交叉个体，以及被选个体将产生多少个子代个体。选择标准按照适应度进行，一般为按比例的适应度计算、基于排序的适用度计算。适应度计算以后，按照适应度进行父代个体选择，有以下算法：</p><ul><li>轮盘赌选择</li><li>随机遍历抽样</li><li>局部选择</li><li>截断选择</li><li>锦标赛选择</li></ul><p><strong>2.交叉</strong></p><p>交叉是结合来自父代交配种群中的信息产生新的个体。依据个体编码表示方法的不同可以有以下算法：</p><ul><li>实值重组(离散、中间、线性、扩展线性)</li><li>二进制交叉(单点、多点、均匀、洗牌、缩小代理)</li></ul><p><strong>3.变异</strong></p><p>交叉之后子代经历的变异，实际上是子代基因按小概率扰动产生的变化。依据个体编码表示方法不同，有实值变异、二进制变异。</p></blockquote><h2 id="二、基本遗传算法"><a href="#二、基本遗传算法" class="headerlink" title="二、基本遗传算法"></a>二、基本遗传算法</h2><h3 id="2-1-算法原理"><a href="#2-1-算法原理" class="headerlink" title="2.1 算法原理"></a>2.1 算法原理</h3><ol><li><p>用二进制编码离散自变量，码长由计算精度确定。如区间$[-10,10]$,精度0.01，码长由计算公式 $log_2\left{[10-(-10)]/0.01+1 \right}=11$ 给出，即每个个体使用11位的二进制编码表示。</p></li><li><p>交叉方法采用单点交叉，例如有两个11位个体在切点第5位发生交叉。</p></li></ol><ol><li>变异是根据变异概率反转子代某个位的值，例如将0变为1，且一般变异概率很小，在0-0.05之间。</li></ol><ol><li>选择策略采用轮盘赌策略。</li></ol><h3 id="2-2-算法步骤与流程"><a href="#2-2-算法步骤与流程" class="headerlink" title="2.2 算法步骤与流程"></a>2.2 算法步骤与流程</h3><h2 id="三、MATLAB代码实现"><a href="#三、MATLAB代码实现" class="headerlink" title="三、MATLAB代码实现"></a>三、MATLAB代码实现</h2><h2 id="四、其他遗传算法"><a href="#四、其他遗传算法" class="headerlink" title="四、其他遗传算法"></a>四、其他遗传算法</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><ol><li><strong>MATLAB智能算法30个案例分析_(史峰，王辉编著)——主</strong></li><li><strong>智能优化算法及其MATLAB实例（第2版）_(包子阳__等)</strong></li><li><strong>精通MATLAB最优化计算（第2版）</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="优化算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-优化算法" scheme="https://chanmoyun.gitee.io/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>实时人脸识别</title>
    <link href="https://chanmoyun.gitee.io/2022/04/12/Opencv-pro/%E5%AE%9E%E6%97%B6%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    <id>https://chanmoyun.gitee.io/2022/04/12/Opencv-pro/%E5%AE%9E%E6%97%B6%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2024-01-09T03:09:57.273Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="实时人脸识别"><a href="#实时人脸识别" class="headerlink" title="实时人脸识别"></a>实时人脸识别</h1><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>你好，我是禅墨！好久，不见！</p><p>    <div id="aplayer-fzksEfMF" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1901371647" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>补上一个之前写好但是在文件夹吃灰的文章，实施人脸识别，需要简单的数据训练！</p><p><strong>代码编写有三个步骤：</strong></p><p>Step1：采集人脸数据和人脸检测</p><p>Step2：训练人脸识别模型</p><p>Step3：人脸识别推理</p><p><img src="https://img-blog.csdnimg.cn/d6ec47fe7d0a484281ed6de6c0798640.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56aF5aKo5LqR,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="一、安装环境"><a href="#一、安装环境" class="headerlink" title="一、安装环境"></a>一、安装环境</h3><p>​    本文采用需要Python + Opencv + Opencv-contrib的组合，完成后可移植在Linux系统</p><ol><li><p>安装Python3.7</p><p>官网：<a href="https://www.python.org/downloads/，推荐版本3.7，第三方库适配多，比较全面">https://www.python.org/downloads/，推荐版本3.7，第三方库适配多，比较全面</a></p><p>安装后需要加入系统环境</p></li><li><p>安装pycharm，此类教程较多，不做过多赘述，社区版足够了</p><p>官网：<a href="">https://www.jetbrains.com/pycharm/</a></p></li><li><p>按照要求安装后需要安装第三方库：opencv-python，采用4.2.0、Opencv-contrib，采用4.5.2</p><p>注意版本，否则会造成版本不匹配出现运行问题</p></li></ol><h3 id="二、调用相机"><a href="#二、调用相机" class="headerlink" title="二、调用相机"></a>二、调用相机</h3><p>接下来就测试一下确认相机是否工作正常。在 IDE 上输入以下 Python 代码：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>) <span class="comment">#0表示调用默认相机、1表示调用usb相机</span></span><br><span class="line">cap.<span class="built_in">set</span>(<span class="number">3</span>,<span class="number">640</span>) <span class="comment">#宽度</span></span><br><span class="line">cap.<span class="built_in">set</span>(<span class="number">4</span>,<span class="number">480</span>) <span class="comment">#高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line">    frame = cv2.flip(frame,<span class="number">1</span>)</span><br><span class="line">    gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;frame&#x27;</span>,frame)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;gray&#x27;</span>,gray)</span><br><span class="line">    k = cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:            <span class="comment">#esc退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows() <span class="comment">#释放所用窗口</span></span><br></pre></td></tr></table></figure></p><p>这段代码可以调用默认Cam，捕获视频流，并且通过黑白模式和RGB模式显示出来。按下Esc即可退出程序。</p><p><img src="https://img-blog.csdnimg.cn/630dc69fa7ff4437afe1cafa84c7211f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56aF5aKo5LqR,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="三、人脸检测"><a href="#三、人脸检测" class="headerlink" title="三、人脸检测"></a>三、人脸检测</h3><p>人脸识别中的最基本任务是实现人脸检测，要先在一张图片中捕获到人脸，再去识别图片中的人脸和数据库中人脸数据进行比较。</p><p>人脸检测的最常见方法是使用”Haar 分类器”。基于 Haar 功能的级联分类器的对象检测是 Paul Viola 和 Michael Jones 提出的一种有效的对象检测、基于机器学习的方法。</p><p>进行人脸检测工作该算法需要大量的正图像（有人脸图像）和负图像（无人脸的图像）来训练分类器，然后从中提取特征。OpenCV 可以进行人脸的训练和推理。如果想训练自己的分类器为任何对象，如汽车，飞机等，也是可以用opencv去训练的。当然如果不想创建自己的分类器，OpenCV 已经包含许多预先训练过的面部、眼睛、微笑等分类器。这些 XML 文件可以从 haarcascades 目录下载。</p><p>XML下载网址：<a href="https://github.com/opencv/opencv/tree/master/data/haarcascades">opencv/data/haarcascades at master · opencv/opencv · GitHub</a></p><p>代码如下：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">faceCascade = cv2.CascadeClassifier(<span class="string">&#x27;Cascades/haarcascade_frontalface_default.xml&#x27;</span>)</span><br><span class="line"><span class="comment">#引入级联分类器文件</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">cap.<span class="built_in">set</span>(<span class="number">3</span>,<span class="number">640</span>) <span class="comment">#  Width</span></span><br><span class="line">cap.<span class="built_in">set</span>(<span class="number">4</span>,<span class="number">480</span>) <span class="comment">#  Height</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, img = cap.read()</span><br><span class="line">    img = cv2.flip(img, <span class="number">1</span>)</span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    faces = faceCascade.detectMultiScale(</span><br><span class="line">        gray, scaleFactor=<span class="number">1.2</span>, minNeighbors=<span class="number">5</span>, minSize=(<span class="number">20</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">        cv2.rectangle(img,(x,y),(x+w,y+h),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">        roi_gray = gray[y:y+h, x:x+w]</span><br><span class="line">        roi_color = img[y:y+h, x:x+w]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;video&#x27;</span>,img)</span><br><span class="line"></span><br><span class="line">    k = cv2.waitKey(<span class="number">30</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>: <span class="comment"># &#x27;ESC&#x27; 退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><p>其中代码的这一部分是调用我们的分类器功能：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">faces = faceCascade.detectMultiScale(</span><br><span class="line">        gray,</span><br><span class="line">        scaleFactor=<span class="number">1.2</span>, </span><br><span class="line">        minNeighbors=<span class="number">5</span>, </span><br><span class="line">        minSize=(<span class="number">20</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure></p><p>代码这一部分用来“标记（返回数值）”图像中的面孔，</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">       cv2.rectangle(img,(x,y),(x+w,y+h),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">       roi_gray = gray[y:y+h, x:x+w]</span><br><span class="line">       roi_color = img[y:y+h, x:x+w]</span><br></pre></td></tr></table></figure></p><p>如果发现人脸，它会返回检测到的面部位置，作为左上角（x，y）的矩形，并将”w”作为宽度，将”h”作为高度 = =（x，y，w，h）。如下图：</p><p><img src="https://img-blog.csdnimg.cn/7c16cc73743d4e469e182859a294b1d1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56aF5aKo5LqR,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>如果可以实现以上功能，人脸检测功能基本实现，可以运行python代码。效果是这样的:</p><p><img src="https://img-blog.csdnimg.cn/0164cc483b8446ba8b803e07d0b4cf4d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56aF5aKo5LqR,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="四、采集人脸数据"><a href="#四、采集人脸数据" class="headerlink" title="四、采集人脸数据"></a>四、采集人脸数据</h3><p>让我们开始项目代码的第一阶段。我们在这要存储每个ID的一组照片用来后续进行人脸识别</p><p><img src="https://img-blog.csdnimg.cn/050b7c944b1b436f8486925a3dba5d40.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56aF5aKo5LqR,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>首先创建一个开发项目：FacialRecognition工程，创建一个数据集Dataset，存储我们的面部标本数据集。并且存储上述的调用默认Cam代码和人脸检测代码：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">cam = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">cam.<span class="built_in">set</span>(<span class="number">3</span>, <span class="number">640</span>) <span class="comment">#width</span></span><br><span class="line">cam.<span class="built_in">set</span>(<span class="number">4</span>, <span class="number">480</span>) <span class="comment">#height</span></span><br><span class="line"></span><br><span class="line">face_detector = cv2.CascadeClassifier(<span class="string">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##对每个人来说，输入一个数字表面id</span></span><br><span class="line">face_id = <span class="built_in">input</span>(<span class="string">&#x27;\n enter user id end press &lt;return&gt; ==&gt;  &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n [INFO] Initializing face capture. Look the camera and wait ...&quot;</span>)</span><br><span class="line"><span class="comment"># 初始化单个采样面数量</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"></span><br><span class="line">    ret, img = cam.read()</span><br><span class="line">    img = cv2.flip(img, <span class="number">1</span>) <span class="comment"># flip video image vertically</span></span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    faces = face_detector.detectMultiScale(gray, <span class="number">1.3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">        cv2.rectangle(img, (x,y), (x+w,y+h), (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">2</span>)     </span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Save the captured image into the datasets folder</span></span><br><span class="line">        cv2.imwrite(<span class="string">&quot;dataset/User.&quot;</span> + <span class="built_in">str</span>(face_id) + <span class="string">&#x27;.&#x27;</span> + <span class="built_in">str</span>(count) + <span class="string">&quot;.jpg&quot;</span>, gray[y:y+h,x:x+w])</span><br><span class="line"></span><br><span class="line">        cv2.imshow(<span class="string">&#x27;image&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line">    k = cv2.waitKey(<span class="number">100</span>) &amp; <span class="number">0xff</span> <span class="comment"># Press &#x27;ESC&#x27; for exiting video</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> count &gt;= <span class="number">30</span>: <span class="comment"># 30个样本后停止视频，也可酌情更改数量</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cam.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><p>对于每个捕获的帧，我们都把他保存在”dataset”目录上的文件。.注意一下，要保存上述文件，必须导入库”os”。每个文件的名称格式：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imwrite(&quot;dataset/User.&quot; + str(face_id) + &#x27;.&#x27; + str(count) + &quot;.jpg&quot;, gray[y:y+h,x:x+w])</span><br></pre></td></tr></table></figure></p><blockquote><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.face_id.count.jpg</span><br></pre></td></tr></table></figure></p></blockquote><p>就像这样：</p><p><img src="https://img-blog.csdnimg.cn/a8a07e70115b4066af3e1c348962b5d9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56aF5aKo5LqR,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="五、训练模型"><a href="#五、训练模型" class="headerlink" title="五、训练模型"></a>五、训练模型</h3><p>现在要把之前存储的各个id号的图片提取特征，然后用来训练识别器。最后识别器上会生成一个yml文件。</p><p><img src="https://img-blog.csdnimg.cn/7c277d88c5044d08b4427ec146e23193.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56aF5aKo5LqR,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>首先在终端下载PIL库，函数getImagesAndLabels (path)将从我们刚刚的数据集上收集到ID号和对应的人脸特征</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recognizer = cv2.face.LBPHFaceRecognizer_create()</span><br></pre></td></tr></table></figure></p><p>函数recogizer.train()通过刚刚读取的特征去训练我们的人脸识别器。</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recognizer.train(faces, np.array(ids))</span><br></pre></td></tr></table></figure></p><p><strong>具体代码如下：</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 人脸图像数据库的路径</span></span><br><span class="line">path = <span class="string">&#x27;dataset&#x27;</span></span><br><span class="line"></span><br><span class="line">recognizer = cv2.face.LBPHFaceRecognizer_create()</span><br><span class="line">detector = cv2.CascadeClassifier(<span class="string">&quot;haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数来获取图像和标签数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getImagesAndLabels</span>(<span class="params">path</span>):</span><br><span class="line"></span><br><span class="line">    imagePaths = [os.path.join(path,f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(path)]     </span><br><span class="line">    faceSamples=[]</span><br><span class="line">    ids = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> imagePath <span class="keyword">in</span> imagePaths:</span><br><span class="line"></span><br><span class="line">        PIL_img = Image.<span class="built_in">open</span>(imagePath).convert(<span class="string">&#x27;L&#x27;</span>) <span class="comment"># 将其转换为灰度</span></span><br><span class="line">        img_numpy = np.array(PIL_img,<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line">        iid=os.path.split(imagePath)[-<span class="number">1</span>].split(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(iid)</span><br><span class="line">        <span class="built_in">id</span> = <span class="built_in">int</span>(os.path.split(imagePath)[-<span class="number">1</span>].split(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">        faces = detector.detectMultiScale(img_numpy)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">            faceSamples.append(img_numpy[y:y+h,x:x+w])</span><br><span class="line">            ids.append(<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> faceSamples,ids</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;\n [INFO] Training faces. It will take a few seconds. Wait ...&quot;</span>)</span><br><span class="line">faces,ids = getImagesAndLabels(path)</span><br><span class="line">recognizer.train(faces, np.array(ids))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存训练出的模型于 trainer/trainer.yml</span></span><br><span class="line">recognizer.write(<span class="string">&#x27;trainer/trainer.yml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印训练的序号并结束程序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n [INFO] &#123;0&#125; faces trained. Exiting Program&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(np.unique(ids))))</span><br></pre></td></tr></table></figure></p><p>结果：</p><p><img src="https://img-blog.csdnimg.cn/f69f9dba9a9a4d99a4ec12eb0d676118.png#pic_center" alt="在这里插入图片描述"></p><h3 id="第六步：人脸识别"><a href="#第六步：人脸识别" class="headerlink" title="第六步：人脸识别"></a>第六步：人脸识别</h3><p>人脸识别器已经实现，现在要在相机上捕获人脸。如果此人之前拍摄并训练过他的脸，识别器将做出预测，返回ID名和索引。</p><p><img src="https://img-blog.csdnimg.cn/08264505bca046bfbd4ffdb24f80b215.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56aF5aKo5LqR,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>使用刚刚训练的识别器模型(加载trainer.yml)，这里使用了新的数组，用姓名代替之前的标号，然后就和刚刚“人脸分类器”的步骤一样去进行人脸识别，并且recognizer.predict将返回每张图片识别后的匹配率。</p><p>具体代码如下：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line">recognizer = cv2.face.LBPHFaceRecognizer_create()</span><br><span class="line">recognizer.read(<span class="string">&#x27;trainer/trainer.yml&#x27;</span>)</span><br><span class="line">cascadePath = <span class="string">&quot;haarcascade_frontalface_default.xml&quot;</span></span><br><span class="line">faceCascade = cv2.CascadeClassifier(cascadePath);</span><br><span class="line"></span><br><span class="line">font = cv2.FONT_HERSHEY_SIMPLEX</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化身份计数器</span></span><br><span class="line"><span class="built_in">id</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相关id名称：例如==&gt;马塞洛：id=1 等等</span></span><br><span class="line">names = [<span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;Chanmo&#x27;</span>, <span class="string">&#x27;Wang&#x27;</span>,]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化和启动实时视频捕获</span></span><br><span class="line">cam = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">cam.<span class="built_in">set</span>(<span class="number">3</span>, <span class="number">640</span>) <span class="comment">#  widht</span></span><br><span class="line">cam.<span class="built_in">set</span>(<span class="number">4</span>, <span class="number">480</span>) <span class="comment"># height</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义最小化到检测框大小被承认为一张脸</span></span><br><span class="line">minW = <span class="number">0.1</span>*cam.get(<span class="number">3</span>)</span><br><span class="line">minH = <span class="number">0.1</span>*cam.get(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    ret, img =cam.read()</span><br><span class="line">    img = cv2.flip(img, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    faces = faceCascade.detectMultiScale( </span><br><span class="line">        gray,</span><br><span class="line">        scaleFactor = <span class="number">1.2</span>,</span><br><span class="line">        minNeighbors = <span class="number">5</span>,</span><br><span class="line">        minSize = (<span class="built_in">int</span>(minW), <span class="built_in">int</span>(minH)),</span><br><span class="line">       )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line"></span><br><span class="line">        cv2.rectangle(img, (x,y), (x+w,y+h), (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">id</span>, confidence = recognizer.predict(gray[y:y+h,x:x+w])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#检查是否完美的匹配</span></span><br><span class="line">        <span class="keyword">if</span> (confidence &lt; <span class="number">100</span>):</span><br><span class="line">            <span class="built_in">id</span> = names[<span class="built_in">id</span>]</span><br><span class="line">            confidence = <span class="string">&quot;  &#123;0&#125;%&quot;</span>.<span class="built_in">format</span>(<span class="built_in">round</span>(<span class="number">100</span> - confidence))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">id</span> = <span class="string">&quot;unknown&quot;</span></span><br><span class="line">            confidence = <span class="string">&quot;  &#123;0&#125;%&quot;</span>.<span class="built_in">format</span>(<span class="built_in">round</span>(<span class="number">100</span> - confidence))</span><br><span class="line">        </span><br><span class="line">        cv2.putText(img, <span class="built_in">str</span>(<span class="built_in">id</span>), (x+<span class="number">5</span>,y-<span class="number">5</span>), font, <span class="number">1</span>, (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">        cv2.putText(img, <span class="built_in">str</span>(confidence), (x+<span class="number">5</span>,y+h-<span class="number">5</span>), font, <span class="number">1</span>, (<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">1</span>)  </span><br><span class="line">    </span><br><span class="line">    cv2.imshow(<span class="string">&#x27;camera&#x27;</span>,img) </span><br><span class="line"></span><br><span class="line">    k = cv2.waitKey(<span class="number">10</span>) &amp; <span class="number">0xff</span> <span class="comment"># Press &#x27;ESC&#x27; for exiting video</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n [INFO] Exiting Program and cleanup stuff&quot;</span>)</span><br><span class="line">cam.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>结果展示：</p><p><img src="https://img-blog.csdnimg.cn/676ca5e03401477a8eb7d72ea03db303.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56aF5aKo5LqR,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/categories/Python/"/>
    
    <category term="OpenCv" scheme="https://chanmoyun.gitee.io/categories/Python/OpenCv/"/>
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/tags/Python/"/>
    
    <category term="OpenCv" scheme="https://chanmoyun.gitee.io/tags/OpenCv/"/>
    
    <category term="实战" scheme="https://chanmoyun.gitee.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>利用Matlab快速构建栅格地图</title>
    <link href="https://chanmoyun.gitee.io/2022/04/11/Path-planning/%E5%88%A9%E7%94%A8Matlab%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/"/>
    <id>https://chanmoyun.gitee.io/2022/04/11/Path-planning/%E5%88%A9%E7%94%A8Matlab%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2024-01-11T10:43:35.398Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="利用Matlab快速构建栅格地图"><a href="#利用Matlab快速构建栅格地图" class="headerlink" title="利用Matlab快速构建栅格地图"></a>利用Matlab快速构建栅格地图</h1><h3 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h3><p>你好，我是禅墨！好久，不见！</p><p>    <div id="aplayer-uncsOaHU" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1888915574" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>在这之后，会陆续出路径规划系列，重点在几大算法的Matlab的仿真。学习参考来自黎万洪老师，让我们共同进步，加油！</p><p>​         栅格图像，也称光栅图像，是指在空间和亮度上都已经离散化了的图像。我们可以把一幅栅格图像考虑为一个矩阵，矩阵中的任一元素对应于图像中的一个点，而相应的值对应于该点的灰度级，数字矩阵中的元素叫做像素。</p><h3 id="二、地图分类"><a href="#二、地图分类" class="headerlink" title="二、地图分类"></a>二、地图分类</h3><p><strong>1.尺度地图：</strong></p><p>具有真实的物理尺寸，如栅格地图、特征地图、点云地图等，常用于地图构建、定位、SLAM、小规模路径规划。</p><p><strong>2.拓扑地图：</strong></p><p>不具备真实的物理尺寸，只表示不同地点的连通关系 和距离，如铁路网。</p><p><strong>3.语义地图：</strong></p><p>加标签的尺度地图，常用于人机交互，如百度地图。</p><h3 id="三、栅格地图优势"><a href="#三、栅格地图优势" class="headerlink" title="三、栅格地图优势"></a>三、栅格地图优势</h3><ul><li>可以将任意形状轮廓的地图，用足够精细的栅格进行绘制</li><li>每一栅格，可以通过不同颜色表征不同含义</li><li>基于栅格地图进行路径规划有横、纵、斜三个规划方向，对与室内低速度机器人完全可以按照规划路径行走；对于中高速机器人，可以考虑将规划路径平滑处理，适应非完全约束系统。</li></ul><h3 id="四、核心函数及思想"><a href="#四、核心函数及思想" class="headerlink" title="四、核心函数及思想"></a>四、核心函数及思想</h3><ul><li>colormap: 为栅格地图创建自定义颜色</li><li>sub2ind: 将行列索引转换为线性索引（自上而下，自左往右）</li><li>ind2sub：将线性索引转换为行列索引</li><li>image：利用colormap建立的颜色图，将数组信息显示为图像</li></ul><h3 id="五、Matlab程序及注释"><a href="#五、Matlab程序及注释" class="headerlink" title="五、Matlab程序及注释"></a>五、Matlab程序及注释</h3><p>% 利用Matlab快速绘制栅格地图</p><p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 构建颜色MAP图</span></span><br><span class="line">cmap = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>; ...       <span class="comment">% 1-白色-空地</span></span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 2-黑色-静态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; ...           <span class="comment">% 3-红色-动态障碍</span></span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>;...            <span class="comment">% 4-黄色-起始点 </span></span><br><span class="line">    <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;...            <span class="comment">% 5-品红-目标点</span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>; ...           <span class="comment">% 6-绿色-到目标点的规划路径   </span></span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>];              <span class="comment">% 7-青色-动态规划的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 构建颜色MAP图</span></span><br><span class="line">colormap(cmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 构建栅格地图场景</span></span><br><span class="line"><span class="comment">% 栅格界面大小:行数和列数</span></span><br><span class="line">rows = <span class="number">10</span>;</span><br><span class="line">cols = <span class="number">20</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义栅格地图全域，并初始化空白区域</span></span><br><span class="line">field = <span class="built_in">ones</span>(rows, cols);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 障碍物区域</span></span><br><span class="line">obsRate = <span class="number">0.3</span>;</span><br><span class="line">obsNum = <span class="built_in">floor</span>(rows*cols*obsRate);</span><br><span class="line">obsIndex = randi([<span class="number">1</span>,rows*cols],obsNum,<span class="number">1</span>);</span><br><span class="line">field(obsIndex) = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 起始点和目标点</span></span><br><span class="line">startPos = <span class="number">2</span>;</span><br><span class="line">goalPos = rows*cols<span class="number">-2</span>;</span><br><span class="line">field(startPos) = <span class="number">4</span>;</span><br><span class="line">field(goalPos) = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画栅格图</span></span><br><span class="line">image(<span class="number">1.5</span>,<span class="number">1.5</span>,field);</span><br><span class="line">grid on;</span><br><span class="line">set(gca,<span class="string">&#x27;gridline&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;gridcolor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;GridAlpha&#x27;</span>,<span class="number">0.5</span>);</span><br><span class="line">set(gca,<span class="string">&#x27;xtick&#x27;</span>,<span class="number">1</span>:cols+<span class="number">1</span>,<span class="string">&#x27;ytick&#x27;</span>,<span class="number">1</span>:rows+<span class="number">1</span>);</span><br><span class="line">axis image;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="仿真" scheme="https://chanmoyun.gitee.io/categories/%E4%BB%BF%E7%9C%9F/"/>
    
    <category term="路径规划" scheme="https://chanmoyun.gitee.io/categories/%E4%BB%BF%E7%9C%9F/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
    
    <category term="路径规划" scheme="https://chanmoyun.gitee.io/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
    <category term="MatLab" scheme="https://chanmoyun.gitee.io/tags/MatLab/"/>
    
  </entry>
  
  <entry>
    <title>03|数组：为什么很多编程语言中数组都从0开始编号？</title>
    <link href="https://chanmoyun.gitee.io/2021/07/28/Data-structure/03.%E6%95%B0%E7%BB%84%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E7%BB%84%E9%83%BD%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%BC%96%E5%8F%B7%EF%BC%9F/"/>
    <id>https://chanmoyun.gitee.io/2021/07/28/Data-structure/03.%E6%95%B0%E7%BB%84%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E7%BB%84%E9%83%BD%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%BC%96%E5%8F%B7%EF%BC%9F/</id>
    <published>2021-07-27T16:00:00.000Z</published>
    <updated>2024-02-29T13:03:43.172Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数组：为什么很多编程语言中数组都从0开始编号？"><a href="#数组：为什么很多编程语言中数组都从0开始编号？" class="headerlink" title="数组：为什么很多编程语言中数组都从0开始编号？"></a>数组：为什么很多编程语言中数组都从0开始编号？</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>你好，我是<strong>禅墨</strong>！</p><p>    <div id="aplayer-BwDytZif" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1372796676" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>提到数组，我想你肯定不陌生，甚至还会自信地说，它很简单啊。</p><p>是的，在每一种编程语言中，基本都会有数组这种数据类型。不过，它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。尽管数组看起来非常基础、简单，但是我估计很多人都并没有理解这个基础数据结构的精髓。</p><p>在大部分编程语言中，数组都是从 0 开始编号的，但你是否下意识地想过，<strong>为什么数组要从 0 开始编号，而不是从 1 开始呢？</strong> 从 1 开始不是更符合人类的思维习惯吗？</p><p>你可以带着这个问题来学习接下来的内容。如何实现随机访问？</p><h2 id="如何实现随机访问？"><a href="#如何实现随机访问？" class="headerlink" title="如何实现随机访问？"></a>如何实现随机访问？</h2><p>什么是数组？我估计你心中已经有了答案。不过，我还是想用专业的话来给你做下解释。<strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p><p>这个定义里有几个关键词，理解了这几个关键词，我想你就能彻底掌握数组的概念了。下面就从我的角度分别给你“点拨”一下</p><p>第一是<strong>线性表</strong>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/5%202.jpg" alt="在这里插入图片描述"></p><p>而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/5%203.jpg" alt="在这里插入图片描述"></p><p>第二个是<strong>连续的内存空间和相同类型的数据。</strong>正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p><p>说到数据的访问，那你知道数组是如何实现根据下标随机访问数组元素的吗？</p><p>我们拿一个长度为 10 的 int 类型的数组 int[] a = new int[10]来举例。在我画的这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/5%204.jpg" alt="在这里插入图片描述"></p><p>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><blockquote><p>a[i]_address = base_address + i * data_type_size</p></blockquote><p>其中 data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。这个公式非常简单，我就不多做解释了。</p><p>这里我要特别纠正一个“错误”。我在面试的时候，常常会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。</p><p>实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。</p><h2 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h2><p>前面概念部分我们提到，数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。现在我们就来详细说一下，究竟为什么会导致低效？又有哪些改进方法呢？</p><p>我们先来看<strong>插入操作</strong>。</p><p>假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？你可以自己先试着分析一下。</p><p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。</p><p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</p><p>为了更好地理解，我们举一个例子。假设数组 a[10]中存储了如下 5 个元素：a，b，c，d，e。</p><p>我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2]赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/5%205.jpg" alt="在这里插入图片描述"></p><p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。这个处理思想在快排中也会用到，我会在排序那一节具体来讲，这里就说到这儿。</p><p>我们再来看删除操作。</p><p>跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。</p><p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p><p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？</p><p>我们继续来看例子。数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/5%206.jpg" alt="在这里插入图片描述"></p><p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p><p>如果你了解 JVM，你会发现，这不就是 JVM 标记清除垃圾回收算法的核心思想吗？没错，数据结构和算法的魅力就在于此，<strong>很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧</strong>，这些东西才是最有价值的。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。警惕数组的访问越界问题</p><h2 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h2><p>了解了数组的几个基本操作后，我们来聊聊数组访问越界的问题。</p><p>首先，我请你来分析一下这段 C 语言代码的运行结果：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你发现问题了吗？这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？</p><p>因为，数组大小为 3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致 for 循环的结束条件错写为了 i&lt;=3 而非 i&lt;3，所以当 i=3 时，数组 a[3]访问越界。</p><p>我们知道，在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。</p><p>数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p><p>这种情况下，一般都会出现莫名其妙的逻辑错误，就像我们刚刚举的那个例子，debug 的难度非常的大。而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。</p><p>但并非所有的语言都像 C 一样，把数组越界检查的工作丢给程序员来做，像 Java 本身就会做越界检查，比如下面这几行 Java 代码，就会抛出 java.lang.ArrayIndexOutOfBoundsException。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><h2 id="容器能否完全替代数组？"><a href="#容器能否完全替代数组？" class="headerlink" title="容器能否完全替代数组？"></a>容器能否完全替代数组？</h2><p>针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？</p><p>这里我拿 Java 语言来举例。如果你是 Java 工程师，几乎天天都在用 ArrayList，对它应该非常熟悉。那它与数组相比，到底有哪些优势呢？</p><p>我个人觉得，ArrayList 最大的优势就是<strong>可以将很多数组操作的细节封装起来</strong>。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是<strong>支持动态扩容</strong>。</p><p>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。</p><p>如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。</p><p>不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。</p><p>比如我们要从数据库中取出 10000 条数据放入 ArrayList。我们看下面这几行代码，你会发现，相比之下，事先指定数据大小可以省掉很多次内存申请和数据搬移操作。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ArrayList&lt;User&gt; users = new ArrayList(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">  users.add(xxx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>作为高级语言编程者，是不是数组就无用武之地了呢？当然不是，有些时候，用数组会更合适些，我总结了几点自己的经验。</p><p>1.Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</p><p>2.如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</p><p>3.还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList &gt; array。</p><p>我总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>现在我们来思考开篇的问题：为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？</p><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：</p><blockquote><p>a[k]_address = base_address + k * type_size</p></blockquote><p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：</p><blockquote><p>a[k]_address = base_address + (k-1)*type_size</p></blockquote><p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p><p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p><p>不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非 0 开始不可。所以我觉得最主要的原因可能是历史原因。</p><p>C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>我们今天学习了数组。它可以说是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>1.前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念。我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。</p><p>情况时间复杂度为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。</p><h2 id="课后思考-1"><a href="#课后思考-1" class="headerlink" title="课后思考"></a>课后思考</h2><p>1.前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念。我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。</p><p>2.前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？</p><blockquote><p>我是    <strong>禅墨</strong> ，欢迎关注 <strong>微信公众号：禅墨小栈</strong><br><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/20200513234341292.gif" alt=""></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>02|复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</title>
    <link href="https://chanmoyun.gitee.io/2021/07/27/Data-structure/02.%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%B5%85%E6%9E%90%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E3%80%81%E5%B9%B3%E5%9D%87%E3%80%81%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://chanmoyun.gitee.io/2021/07/27/Data-structure/02.%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%B5%85%E6%9E%90%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E3%80%81%E5%B9%B3%E5%9D%87%E3%80%81%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2021-07-26T16:00:00.000Z</published>
    <updated>2024-02-29T13:03:34.341Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度"><a href="#复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度"></a>复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>你好，我是<strong>禅墨</strong>！</p><p>    <div id="aplayer-QnMvHpIW" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1374061038" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>上一节，我们讲了复杂度的大 O 表示法和几个分析技巧，还举了一些常见复杂度分析的例子，比如 O(1)、O(logn)、O(n)、O(nlogn) 复杂度分析。掌握了这些内容，对于复杂度分析这个知识点，你已经可以到及格线了。但是，我想你肯定不会满足于此。</p><p>今天我会继续给你讲四个复杂度分析方面的知识点，<strong>最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）</strong>。如果这几个概念你都能掌握，那对你来说，复杂度分析这部分内容就没什么大问题了。</p><h2 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h2><p>上一节我举的分析复杂度的例子都很简单，今天我们来看一个稍微复杂的。你可以用我上节教你的分析技巧，自己先试着分析一下这段代码的时间复杂度。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// n表示数组array的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] <span class="built_in">array</span>, <span class="type">int</span> n, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你应该可以看出来，这段代码要实现的功能是，在一个无序的数组（array）中，查找变量 x 出现的位置。如果没有找到，就返回 -1。按照上节课讲的分析方法，这段代码的复杂度是 O(n)，其中，n 代表数组的长度。</p><p>我们在数组中查找一个数据，并不需要每次都把整个数组都遍历一遍，因为有可能中途找到就可以提前结束循环了。但是，这段代码写得不够高效。我们可以这样优化一下这段查找代码。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// n表示数组array的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] <span class="built_in">array</span>, <span class="type">int</span> n, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个时候，问题就来了。我们优化完之后，这段代码的时间复杂度还是 O(n) 吗？很显然，咱们上一节讲的分析方法，解决不了这个问题。</p><p>因为，要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。</p><p>为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。</p><p>顾名思义，<strong>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度</strong>。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。</p><p>同理，<strong>最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度</strong>。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。</p><h2 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h2><p>我们都知道，最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，我们需要引入另一个概念：</p><p>平均情况时间复杂度，后面我简称为平均时间复杂度。平均时间复杂度又该怎么分析呢？我还是借助刚才查找变量 x 的例子来给你解释。</p><p>要查找的变量 x 在数组中的位置，有 n+1 种情况：<strong>在数组的 0～n-1 位置中和不在数组中。</strong>我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/4%202.jpg" alt="在这里插入图片描述"></p><p>我们知道，时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。</p><p>这个结论虽然是正确的，但是计算过程稍微有点儿问题。究竟是什么问题呢？我们刚讲的这 n+1 种情况，出现的概率并不是一样的。我带你具体分析一下。（这里要稍微用到一点儿概率论的知识，不过非常简单，你不用担心。）</p><p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。</p><p>因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/4%203.jpg" alt="在这里插入图片描述"></p><p>这个值就是概率论中的<strong>加权平均值，也叫作期望值，</strong>所以平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</p><p>引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。</p><p>你可能会说，平均时间复杂度分析好复杂啊，还要涉及概率论的知识。实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。像我们上一节课举的那些例子那样，很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。</p><h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h2><p>到此为止，你应该已经掌握了算法复杂度分析的大部分内容了。下面我要给你讲一个更加高级的概念，均摊时间复杂度，以及它对应的分析方法，摊还分析（或者叫平摊分析）。</p><p>均摊时间复杂度，听起来跟平均时间复杂度有点儿像。对于初学者来说，这两个概念确实非常容易弄混。我前面说了，大部分情况下，我们并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。</p><p>老规矩，我还是借助一个具体的例子来帮助你理解。（当然，这个例子只是我为了方便讲解想出来的，实际上没人会这么写。）</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// array表示一个长度为n的数组</span></span><br><span class="line"><span class="comment">// 代码中的array.length就等于n</span></span><br><span class="line"><span class="type">int</span>[] <span class="built_in">array</span> = new <span class="type">int</span>[n];</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (count == <span class="built_in">array</span>.length) &#123;</span><br><span class="line">      <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; ++i) &#123;</span><br><span class="line">         sum = sum + <span class="built_in">array</span>[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">array</span>[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">array</span>[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我先来解释一下这段代码。这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p><p>那这段代码的时间复杂度是多少呢？你可以先用我们刚讲到的三种时间复杂度的分析方法来分析一下。</p><p>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p><p>那平均时间复杂度是多少呢？答案是 O(1)。我们还是可以通过前面讲的概率论的方法来分析。</p><p>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/4%204.jpg" alt="在这里插入图片描述"></p><p>至此为止，前面的最好、最坏、平均时间复杂度的计算，理解起来应该都没有问题。但是这个例子里的平均复杂度分析其实并不需要这么复杂，不需要引入概率论的知识。这是为什么呢？我们先来对比一下这个 insert() 的例子和前面那个 find() 的例子，你就会发现这两者有很大差别。</p><p>首先，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()<strong>第一个</strong>区别于 find() 的地方。</p><p>我们再来看<strong>第二个</strong>不同的地方。对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</p><p>所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。</p><p>针对这种特殊的场景，我们引入了一种更加简单的分析方法：<strong>摊还分析法</strong>，通过摊还分析得到的时间复杂度我们起了一个名字，叫<strong>均摊时间复杂度</strong>。</p><p>那究竟如何使用摊还分析法来分析算法的均摊时间复杂度呢？</p><p>我们还是继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。你都理解了吗？</p><p>均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。为了方便你理解、记忆，我这里简单总结一下它们的应用场景。如果你遇到了，知道是怎么回事儿就行了。</p><p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p><p>尽管很多数据结构和算法书籍都花了很大力气来区分平均时间复杂度和均摊时间复杂度，但其实我个人认为，<strong>均摊时间复杂度就是一种特殊的平均时间复杂度</strong>，我们没必要花太多精力去区分它们。你最应该掌握的是它的分析方法，摊还分析。至于分析出来的结果是叫平均还是叫均摊，这只是个说法，并不重要。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们学习了几个复杂度分析相关的概念，分别有：最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度、均摊时间复杂度。之所以引入这几个复杂度概念，是因为，同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的。</p><p>在引入这几个概念之后，我们可以更加全面地表示一段代码的执行效率。而且，这几个概念理解起来都不难。最好、最坏情况下的时间复杂度分析起来比较简单，但平均、均摊两个复杂度分析相对比较复杂。如果你觉得理解得还不是很深入，不用担心，在后续具体的数据结构和算法学习中，我们可以继续慢慢实践！</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>我们今天学的几个复杂度分析方法，你都掌握了吗？你可以用今天学习的知识，来分析一下下面这个 add() 函数的时间复杂度。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，大小为10的数组array，长度len，下标i。</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[] = new <span class="type">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="type">int</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往数组中添加一个元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (i &gt;= len) &#123; <span class="comment">// 数组空间不够了</span></span><br><span class="line">     <span class="comment">// 重新申请一个2倍大小的数组空间</span></span><br><span class="line">     <span class="type">int</span> new_array[] = new <span class="type">int</span>[len*<span class="number">2</span>];</span><br><span class="line">     <span class="comment">// 把原来array数组中的数据依次copy到new_array</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">       new_array[j] = <span class="built_in">array</span>[j];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// new_array复制给array，array现在大小就是2倍len了</span></span><br><span class="line">     <span class="built_in">array</span> = new_array;</span><br><span class="line">     len = <span class="number">2</span> * len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将element放到下标为i的位置，下标i加一</span></span><br><span class="line">   <span class="built_in">array</span>[i] = element;</span><br><span class="line">   ++i;</span><br><span class="line">&#125;</span><br><span class="line">​```</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// new_array复制给array，array现在大小就是2倍len了</span></span><br><span class="line">     <span class="built_in">array</span> = new_array;</span><br><span class="line">     len = <span class="number">2</span> * len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将element放到下标为i的位置，下标i加一</span></span><br><span class="line">   <span class="built_in">array</span>[i] = element;</span><br><span class="line">   ++i;</span><br><span class="line">&#125;</span><br><span class="line">​```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>我是禅墨，欢迎关注微信公众号：</p><blockquote><p>这里是引用<br><img src="https://img-blog.csdnimg.cn/20200725180147220.gif#pic_center" alt="在这里插入图片描述"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>01|复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</title>
    <link href="https://chanmoyun.gitee.io/2021/07/25/Data-structure/01.%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E3%80%81%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%EF%BC%9F/"/>
    <id>https://chanmoyun.gitee.io/2021/07/25/Data-structure/01.%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E3%80%81%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%EF%BC%9F/</id>
    <published>2021-07-24T16:00:00.000Z</published>
    <updated>2024-02-29T13:03:25.721Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？"><a href="#复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？" class="headerlink" title="复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？"></a>复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>你好，我是<strong>禅墨</strong>！</p><p>    <div id="aplayer-gshNsyXV" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="29567192" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>我们都知道，数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到我们今天要讲的内容：时间、空间复杂度分析。</p><p>其实，只要讲到数据结构与算法，就一定离不开时间、空间复杂度分析。而且，我个人认为，<strong>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半</strong>。</p><p>复杂度分析实在太重要了，希望在学完这个内容之后，无论在任何场景下，面对任何代码的复杂度分析，都能做到“庖丁解牛”般游刃有余。</p><h2 id="为什么需要复杂度分析？"><a href="#为什么需要复杂度分析？" class="headerlink" title="为什么需要复杂度分析？"></a>为什么需要复杂度分析？</h2><p>你可能会有些疑惑，我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？</p><p>首先，我可以肯定地说，你这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫事后统计法。但是，这种统计方法有非常大的局限性。</p><h3 id="1-测试结果非常依赖测试环境"><a href="#1-测试结果非常依赖测试环境" class="headerlink" title="1. 测试结果非常依赖测试环境"></a>1. 测试结果非常依赖测试环境</h3><p>测试环境中硬件的不同会对测试结果有很大的影响。比如，我们拿同样一段代码，分别用 Intel Core i9 处理器和 Intel Core i3 处理器来运行，不用说，i9 处理器要比 i3 处理器执行的速度快很多。还有，比如原本在这台机器上 a 代码执行的速度比 b 代码要快，等我们换到另一台机器上时，可能会有截然相反的结果。</p><h3 id="2-测试结果受数据规模的影响很大"><a href="#2-测试结果受数据规模的影响很大" class="headerlink" title="2. 测试结果受数据规模的影响很大"></a>2. 测试结果受数据规模的影响很大</h3><p>后面我们会讲排序算法，我们先拿它举个例子。对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反应算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快！</p><p>所以，<strong>我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法</strong>。这就是我们今天要讲的时间、空间复杂度分析方法。</p><h2 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h2><p>算法的执行效率，粗略地讲，就是算法代码执行的时间。但是，如何在不运行代码的情况下，用“肉眼”得到一段代码的执行时间呢？这里有段非常简单的代码，求 1,2,3…n 的累加和。现在，我就带你一块来估算一下这段代码的执行时间。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行c的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？</p><p>第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n<em>unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)</em>unit_time。可以看出来，所有代码的执行时间 T(n) 与每行代码的执行次数成正比。</p><p>按照这个分析思路，我们再来看这段代码。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">      sum = sum +  i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们依旧假设每个语句的c执行时间是 unit_time。那这段代码的总执行时间 T(n) 是多少呢？</p><p>第 2、3、4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n <em> unit_time 的执行时间，第 7、8 行代码循环执行了 n2遍，所以需要 2n2</em> unit_time 的执行时间。所以，整段代码总的执行时间 T(n) = (2n2+2n+3)*unit_time。</p><p>尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，<strong>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。</strong></p><p>我们可以把这个规律总结成一个公式。注意，大 O 就要登场了！</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/20200725175920367.png" alt=""></p><p>我来具体解释一下这个公式。其中，T(n) 我们已经讲过了，它表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p><p>所以，第一个例子中的 T(n) = O(2n+2)，第二个例子中的 T(n) = O(2n2+2n+3)。这就是<strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是<strong>表示代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。</p><p>当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n2)。</p><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>前面介绍了大 O 时间复杂度的由来和表示方法。现在我们来看下，如何分析一段代码的时间复杂度？我这儿有三个比较实用的方法可以分享给你。</p><h3 id="1-只关注循环执行次数最多的一段代码"><a href="#1-只关注循环执行次数最多的一段代码" class="headerlink" title="1.只关注循环执行次数最多的一段代码"></a>1.只关注循环执行次数最多的一段代码</h3><p>我刚才说了，大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，<strong>我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了</strong>。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p><p>为了便于你理解，我还拿前面的例子来说明。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。</p><h3 id="2-加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#2-加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="2.加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>2.加法法则：总复杂度等于量级最大的那段代码的复杂度</h3><p>我这里还有一段代码。你可以先试着分析一下，然后再往下看跟我的分析思路是否一样。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="type">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;c</span><br><span class="line">     sum_1 = sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> q = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; q &lt; n; ++q) &#123;</span><br><span class="line">     sum_2 = sum_2 + q;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>; </span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum_3 = sum_3 +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这个代码分为三部分，分别是求 sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。</p><p>第一段的时间复杂度是多少呢？这段代码循环执行了 100 次，所以是一个常量的执行时间，跟 n 的规模无关。</p><p>这里我要再强调一下，即便这段代码循环 10000 次、100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。当 n 无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。</p><p>那第二段代码和第三段代码的时间复杂度是多少呢？答案是 O(n) 和 O(n2)，你应该能容易就分析出来，我就不啰嗦了。</p><p>综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为 O(n2)。也就是说：<strong>总的时间复杂度就等于量级最大的那段代码的时间复杂度</strong>。那我们将这个规律抽象成公式就是：</p><p>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</p><h3 id="3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h3><p>我刚讲了一个复杂度分析中的加法法则，这儿还有一个乘法法则。类比一下，你应该能“猜到”公式是什么样子的吧？</p><p>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)<em>T2(n)=O(f(n))</em>O(g(n))=O(f(n)*g(n)).</p><p>也就是说，假设 T1(n) = O(n)，T2(n) = O(n2)，则 T1(n) * T2(n) = O(n3)。落实到具体的代码上，我们可以把乘法法则看成是嵌套循环，我举个例子给你解释一下。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="type">int</span> ret = <span class="number">0</span>; </span><br><span class="line">   <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret = ret + f(i);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>我们单独看 cal() 函数。假设 f() 只是一个普通的操作，那第 4～6 行的时间复杂度就是，T1(n) = O(n)。但 f() 函数本身不是一个简单的操作，它的时间复杂度是 T2(n) = O(n)，所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) <em> T2(n) = O(n</em>n) = O(n2)。</p><p>我刚刚讲了三种复杂度的分析技巧。不过，你并不用刻意去记忆。实际上，复杂度分析这个东西关键在于“熟练”。你只要多看案例，多分析，就能做到“无招胜有招”。</p><h2 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h2><p>虽然代码千差万别，但是常见的复杂度量级并不多。我稍微总结了一下，这些复杂度量级几乎涵盖了你今后可以接触的所有代码的复杂度量级。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/3%202.jpg" alt="在这里插入图片描述"></p><p>对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p><p>我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。</p><p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的多项式时间复杂度。</p><h3 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1.O(1)"></a>1.O(1)</h3><p>首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> sum = i + j;</span><br></pre></td></tr></table></figure></p><p>我稍微总结一下，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，<strong>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</strong></p><h3 id="2-O-logn-、O-nlogn"><a href="#2-O-logn-、O-nlogn" class="headerlink" title="2. O(logn)、O(nlogn)"></a>2. O(logn)、O(nlogn)</h3><p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据我们前面讲的复杂度分析方法c，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p><p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/3%203.jpg" alt=""></p><p>所以，我们只要知道 x 值是多c少，就知道这行代码执行的次数了。通过 2x=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。x=log2n，所以，这段代码的时间复杂度就是 O(log2n)。</p><p>现在，我把代码稍微改下，你再看看，这段代码的时间复杂度是多少？</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据我刚刚讲的思路，很简单就能看出来，这段代码的时间复杂度为 O(log3n)。</p><p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？</p><p>我们知道，对数之间是可以互相转换的，log3n 就等于 log32 <em> log2n，所以 O(log3n) = O(C </em> log2n)，其中 C=log32 是一个常量。基于我们前面的一个理论：<strong>在采用大 O 标记复杂度的时候，可以忽略系数</strong>，即 O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p><p>如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p><h3 id="3-O-m-n-、O-m-n"><a href="#3-O-m-n-、O-m-n" class="headerlink" title="3. O(m+n)、O(m*n)"></a>3. O(m+n)、O(m*n)</h3><p>我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度<strong>由两个数据</strong>的规模来决定。老规矩，先看代码！</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p><p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)<em>T2(n) = O(f(m) </em> f(n))。</p><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>前面，咱们花了很长时间讲大 O 表示法和时间复杂度分析，理解了前面讲的内容，空间复杂度分析方法学起来就非常简单了。</p><p>前面我讲过，时间复杂度的全称是<strong>渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系</strong>。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表<strong>示算法的存储空间与数据规模之间的增长关系。</strong></p><p>我还是拿具体的例子来给你说明。（这段代码有点“傻”，一般没人会这么写，我这么写只是为了方便给你解释。）</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span>[] a = new <span class="type">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p><p>我们常见的空间复杂度就是 O(1)、O(n)、O(n2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>基础复杂度分析的知识到此就讲完了，我们来总结一下。</p><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2)。等你学完整个专栏之后，你就会发现几乎所有的数据结构和算法的复杂度都跑不出这几个。</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/3%204.jpg" alt=""></p><p><strong>复杂度分析并不难，关键在于多练</strong>。 之后讲后面的内容时，我还会带你详细地分析每一种数据结构和算法的时间、空间复杂度。只要跟着我的思路学习、练习，你很快就能和我一样，每次看到代码的时候，简单的一眼就能看出其复杂度，难的稍微分析一下就能得出答案。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？而且，每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？你怎么看待这个问题呢？</p><p>我是<strong>禅墨</strong>，欢迎关注<strong>微信公众号</strong>：<br><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/20200513234341292.gif#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://chanmoyun.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Requests PK 豆瓣&amp;肯德基|6</title>
    <link href="https://chanmoyun.gitee.io/2021/01/31/Reptile-Learn/06.Requests%20PK%20%E8%B1%86%E7%93%A3&amp;%E8%82%AF%E5%BE%B7%E5%9F%BA/"/>
    <id>https://chanmoyun.gitee.io/2021/01/31/Reptile-Learn/06.Requests%20PK%20%E8%B1%86%E7%93%A3&amp;%E8%82%AF%E5%BE%B7%E5%9F%BA/</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2024-01-09T03:09:18.784Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Requests-PK-豆瓣-amp-肯德基"><a href="#Requests-PK-豆瓣-amp-肯德基" class="headerlink" title="Requests PK 豆瓣&amp;肯德基"></a>Requests PK 豆瓣&amp;肯德基</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>你好，我是<strong>禅墨</strong>！</p><p>    <div id="aplayer-kmjLDWpc" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1415078941" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>之前我们主要学习了Requests模块，掌握的怎么样呢，</p><p>今天就做两个小练习，不多说任何废话！</p><p>不知道步骤的可以翻看之前的文章！</p><ul><li><a href="https://blog.csdn.net/qq_44090770/article/details/113263163">Requests第一血</a></li><li><a href="https://blog.csdn.net/qq_44090770/article/details/113327058">简易网页采集</a></li><li><a href="https://blog.csdn.net/qq_44090770/article/details/113376220">破解百度翻译</a></li></ul><h2 id="爬取豆瓣电影排行"><a href="#爬取豆瓣电影排行" class="headerlink" title="爬取豆瓣电影排行"></a>爬取豆瓣电影排行</h2><p>在这里以喜剧为例：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    url = <span class="string">&#x27;https://movie.douban.com/j/chart/top_list?&#x27;</span></span><br><span class="line">    param = &#123;</span><br><span class="line">        <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;24&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;interval_id&#x27;</span>: <span class="string">&#x27;100:90&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;start&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="comment">#从库中的第几部电影去取</span></span><br><span class="line">        <span class="string">&#x27;limit&#x27;</span>: <span class="string">&#x27;20&#x27;</span>, <span class="comment">#一次取出的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url=url,params=param,headers=headers)</span><br><span class="line"></span><br><span class="line">    list_data = response.json()</span><br><span class="line">    <span class="built_in">print</span>(list_data)</span><br><span class="line"></span><br><span class="line">    filename = <span class="built_in">input</span>(<span class="string">&#x27;Enter a word:&#x27;</span>)+<span class="string">&#x27;.json&#x27;</span></span><br><span class="line">    fp = <span class="built_in">open</span>(filename,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    json.dump(list_data,fp=fp,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK!&#x27;</span>)</span><br><span class="line">https://movie.douban.com/typerank?type_name=%E5%<span class="number">96</span>%9C%E5%<span class="number">89</span>%A7&amp;<span class="built_in">type</span>=<span class="number">24</span>&amp;interval_id=<span class="number">100</span>:<span class="number">90</span>&amp;action=</span><br></pre></td></tr></table></figure></p><p><strong>需要注意的是</strong>：之前我们的post请求，都是只带有一个参数的，那多个参数怎么办呢，其实你已经创建过字典了，只需要把其他参数加进去就行了。</p><h2 id="肯德基餐厅位置"><a href="#肯德基餐厅位置" class="headerlink" title="肯德基餐厅位置"></a>肯德基餐厅位置</h2><p>这个就更不用多说了：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    url = <span class="string">&#x27;http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=keyword&#x27;</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">    city = <span class="built_in">input</span>(<span class="string">&quot;Enter a city:&quot;</span>)</span><br><span class="line">    param = &#123;</span><br><span class="line">        <span class="string">&#x27;cname&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pid&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;keyword&#x27;</span>: city,</span><br><span class="line">        <span class="string">&#x27;pageIndex&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pageSize&#x27;</span>: <span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.post(url=url,params=param,headers=headers)</span><br><span class="line">    data_text = response.text</span><br><span class="line">    <span class="built_in">print</span>(data_text)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;filename = city+&#x27;.txt&#x27;</span></span><br><span class="line"><span class="string">    with open(filename,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp:</span></span><br><span class="line"><span class="string">        fp.write(data_text)&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>OK！这就是本篇文章全部内容了！</p><p>欢迎关注禅墨云，我们不见不散！</p><p>博客网站同步更新，网址：<strong>chanmoyun.gitee.io</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/20210129115055180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDkwNzcw,size_16,color_FFFFFF,t_70#pic_center" alt="这里是引用"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/categories/Python/"/>
    
    <category term="爬虫" scheme="https://chanmoyun.gitee.io/categories/Python/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/tags/Python/"/>
    
    <category term="爬虫" scheme="https://chanmoyun.gitee.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>破解百度翻译|5</title>
    <link href="https://chanmoyun.gitee.io/2021/01/29/Reptile-Learn/05.%E7%A0%B4%E8%A7%A3%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91/"/>
    <id>https://chanmoyun.gitee.io/2021/01/29/Reptile-Learn/05.%E7%A0%B4%E8%A7%A3%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91/</id>
    <published>2021-01-28T16:00:00.000Z</published>
    <updated>2024-01-09T03:09:10.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="破解百度翻译-5"><a href="#破解百度翻译-5" class="headerlink" title="破解百度翻译|5"></a>破解百度翻译|5</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>你好，我是<strong>禅墨</strong>！</p><p>    <div id="aplayer-XeMrvVbA" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1409329965" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>转眼间就到了周五了，happy啊！</p><p>上篇文章我们做了一个简易得网页采集器，感觉没啥难度，那这次我们就再做一个没啥难度的东西，搞一下百度翻译，想了想，还是最后把程序打一下包，作为一个小工具使用！</p><h2 id="指定url及响应分析"><a href="#指定url及响应分析" class="headerlink" title="指定url及响应分析"></a>指定url及响应分析</h2><p>你看，爬虫第一步总是要指定URL，但是这个是需要我们在浏览器中寻找的。</p><ol><li>打开浏览器(以Chrome为例)找到百度翻译首页，思考一下，首页会是我们要破解的内容吗？那我们需要获取的内容是哪些呢？不妨我们输入一个单词，比如说:cat，这时我们看一下页面上就会出现具体的内容。那红框线框出来的就是我们需要的内容。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传<img src="https://img-blog.csdnimg.cn/20210129114933572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDkwNzcw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ol><ol><li><p>那我们如何找到这一部分内容呢，按下F12，找network，页面响应对应的XHR，这时会发现什么都没有，我们需要把刚刚的cat删掉，这时我们会在右边直接看到有两个sug,我们点开headers往下查找，会发现从上往下对应的分别是kw:ca，kw:c ，这是不是就是我们删除时留下的字母顺序，那说明我们要找的界面就是它吧。</p><p><img src="https://img-blog.csdnimg.cn/20210129114947512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDkwNzcw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ol><ol><li><p>我们翻看到前面会发现，他的完整请求地址，以及类型为POST，说明这是一个带有参数的请求，参数是什么呢，是不是就是我们刚刚寻找到的kw啊</p><p><img src="https://img-blog.csdnimg.cn/20210129115000976.png#pic_center" alt="在这里插入图片描述"></p></li></ol><ol><li><p>我们来复盘一下，针对这个请求地址，post请求每次多携带一个字符作为参数向服务器发送请求，直到组成我们需要翻译的单词，然后服务器会响应请求，做出回应数据。那么响应类型是什么呢？</p></li><li><p>我们会看到一个Response Headers，这就是响应的具体内容，Content-Type说明这时一个json响应。</p><p><img src="https://img-blog.csdnimg.cn/20210129115011610.png#pic_center" alt="在这里插入图片描述"></p></li></ol><h2 id="编码详情"><a href="#编码详情" class="headerlink" title="编码详情"></a>编码详情</h2><p>前面的准备工作我们已经做的很充分了，后面就是按照正常的顺序进行敲代码了，不清楚的可以回看这里</p><blockquote><p><a href="https://chanmoyun.gitee.io/2021/01/28/04.%E7%AE%80%E6%98%93%E7%BD%91%E9%A1%B5%E9%87%87%E9%9B%86/">https://chanmoyun.gitee.io/2021/01/28/04.%E7%AE%80%E6%98%93%E7%BD%91%E9%A1%B5%E9%87%87%E9%9B%86/</a></p></blockquote><p>在这里需要声明一点，我们之前使用的是text()获取响应数据的，但是对于json类型，我们需要用json()获取响应数据，返回的是obj类型。</p><p>源码及解析：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 1-指定url</span></span><br><span class="line">    post_url = <span class="string">&#x27;https://fanyi.baidu.com/sug&#x27;</span></span><br><span class="line">    <span class="comment"># 2-进行UA伪装</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">    <span class="comment"># 3-post请求参数处理（同get请求一致）</span></span><br><span class="line">    word = <span class="built_in">input</span>(<span class="string">&#x27;Enter a word:&#x27;</span>)</span><br><span class="line">    data = &#123;<span class="string">&#x27;kw&#x27;</span>:word&#125;</span><br><span class="line">    <span class="comment"># 4-请求发送</span></span><br><span class="line">    response = requests.post(url=post_url,data=data,headers=headers)</span><br><span class="line">    <span class="comment"># 5-获取响应数据：json()方法返回的是obj(如果确认响应数据是json类型的，才能使用json())</span></span><br><span class="line">    dic_obj = response.json()</span><br><span class="line">    <span class="built_in">print</span>(dic_obj)</span><br><span class="line">    <span class="comment"># 持久化存储</span></span><br><span class="line">    filename = word+<span class="string">&#x27;.json&#x27;</span></span><br><span class="line">    fp = <span class="built_in">open</span>(filename,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    json.dump(dic_obj,fp=fp,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK!&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="制作exe可执行文件"><a href="#制作exe可执行文件" class="headerlink" title="制作exe可执行文件"></a>制作exe可执行文件</h2><p>当我们想具体使用时，总不能每次都去打开编辑器运行吧，所以我们需要对程序进行打包，有很多方式，这里我们选择pyinstaller工具包</p><ol><li><p>首先，打开工具包，我们直接输入命令，这样安装的就是在全局变量中</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure></p><p>如果之前按照步骤更改过pip镜像源，安装起来就会非常快（文章环境安装部分<a href="https://chanmoyun.gitee.io/2021/01/27/03.Requests%E7%AC%AC%E4%B8%80%E8%A1%80/）">https://chanmoyun.gitee.io/2021/01/27/03.Requests%E7%AC%AC%E4%B8%80%E8%A1%80/）</a></p></li><li><p>安装完成之后，我们可以在cmd中切换到想要打包的文件所在的文件夹下，但是如果使用的pycharm，直接点击下方的Terminal即可。</p></li><li><p>在打包之前，我们需要考虑，程序执行一次只能翻译一个，我们是不是需要给他写成死循环啊，然后我们之前定义的是有永久化存储的，现在也不需要了，所以我们的程序就可以改成：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 1-指定url</span></span><br><span class="line">    post_url = <span class="string">&#x27;https://fanyi.baidu.com/sug&#x27;</span></span><br><span class="line">    <span class="comment"># 2-进行UA伪装</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">    <span class="comment"># 3-post请求参数处理（同get请求一致）</span></span><br><span class="line">    word = <span class="built_in">input</span>(<span class="string">&#x27;Enter a word:&#x27;</span>)</span><br><span class="line">    data = &#123;<span class="string">&#x27;kw&#x27;</span>:word&#125;</span><br><span class="line">    <span class="comment"># 4-请求发送</span></span><br><span class="line">    response = requests.post(url=post_url,data=data,headers=headers)</span><br><span class="line">    <span class="comment"># 5-获取响应数据：json()方法返回的是obj(如果确认响应数据是json类型的，才能使用json())</span></span><br><span class="line">    dic_obj = response.json()</span><br><span class="line">    <span class="built_in">print</span>(dic_obj)</span><br></pre></td></tr></table></figure></p></li><li><p>那你想没想过，pyinstaller打包的是整个环境，如果你的当前环境有很多包，那是不是打包就会很慢，甚至会出现打包失败，就算会成功那也会生成很大的文件，那怎么办？有pycharm这么优秀的工具不能浪费啊，我们可以单独建一个虚拟环境，把py文件写在里面，里面只有需要的包，其他都不要，这样不就全部解决了。</p></li><li><p>接下来就正式打包了</p><p>完整示例(不是本程序)</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -i tra.ico main.py -n Tra --noconsole</span><br></pre></td></tr></table></figure></p><p>| 功能        | 注释                    |<br>| —————- | ———————————- |<br>| -F          | 打包成一个文件          |<br>| -D          | 打包成一个文件夹        |<br>| -n          | 重新命名                |<br>| —noconsole | 去掉cmd                 |<br>| -i          | 加入图标，需要转化为ico |</p><p>针对本程序，我们其实只需要输入简短命令就行</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F Baidu-translation</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>OK！这就是本篇文章全部内容了！</p><p>欢迎关注禅墨云，我们不见不散！</p><p>博客网站同步更新，网址：<strong>chanmoyun.gitee.io</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/20210129115055180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDkwNzcw,size_16,color_FFFFFF,t_70#pic_center" alt="这里是引用"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/categories/Python/"/>
    
    <category term="爬虫" scheme="https://chanmoyun.gitee.io/categories/Python/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/tags/Python/"/>
    
    <category term="爬虫" scheme="https://chanmoyun.gitee.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>简易网页采集器|4</title>
    <link href="https://chanmoyun.gitee.io/2021/01/28/Reptile-Learn/04.%E7%AE%80%E6%98%93%E7%BD%91%E9%A1%B5%E9%87%87%E9%9B%86/"/>
    <id>https://chanmoyun.gitee.io/2021/01/28/Reptile-Learn/04.%E7%AE%80%E6%98%93%E7%BD%91%E9%A1%B5%E9%87%87%E9%9B%86/</id>
    <published>2021-01-27T16:00:00.000Z</published>
    <updated>2024-01-11T09:10:49.606Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简易网页采集-4"><a href="#简易网页采集-4" class="headerlink" title="简易网页采集|4"></a>简易网页采集|4</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>你好，我是<strong>禅墨</strong>！</p><p>    <div id="aplayer-ilOFhTtM" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1811921555" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>之前啊，我们接触到了requests模块，知道他是干什么的，但是要掌握一个模块，就要去练习，去实战。</p><p>之后呢，我们一起做五个小实战项目加以掌握：</p><blockquote><ol><li>简易网页采集器，爬取百度指定词条对应的搜索结果页面</li><li>破解百度翻译</li><li>爬取豆瓣电影分类排行榜，<a href="https://movie.douban.com/">https://movie.douban.com/</a>  中的电影详情数据</li><li>爬取肯德基餐厅查询 <a href="https://www.kfc.com.cn/kfccda/index.aspx">https://www.kfc.com.cn/kfccda/index.aspx</a>  中指定地点的餐厅数据</li><li>爬取国家药品监督管理总局中基于中华人民共和国化妆品生产许可证相关数据  <a href="http://scxk.nmpa.gov.cn:81/xk/">http://scxk.nmpa.gov.cn:81/xk/</a></li></ol></blockquote><p>前四个都是比较简单的项目，最后一个其实是需要一些复杂的步骤的，我们到时候再说，本篇文章我们就先从第一个开始吧！</p><h2 id="编码顺序"><a href="#编码顺序" class="headerlink" title="编码顺序"></a>编码顺序</h2><h4 id="指定url"><a href="#指定url" class="headerlink" title="指定url"></a>指定url</h4><p>首先我们打开百度首页：</p><blockquote><p><a href="https://www.baidu.com/">https://www.baidu.com/</a></p></blockquote><p>输入我们要搜索的词条，以禅墨云为例，我们在网址栏会发现，很长一段字符</p><blockquote><p><a href="https://www.baidu.com/s?wd=禅墨云&amp;rsv_spt=1&amp;rsv_iqid=0xaea3079900012b5e&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=23&amp;rsv_sug1=24&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=12683&amp;rsv_sug4=13427">https://www.baidu.com/s?wd=禅墨云&amp;rsv_spt=1&amp;rsv_iqid=0xaea3079900012b5e&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=23&amp;rsv_sug1=24&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=12683&amp;rsv_sug4=13427</a></p></blockquote><p>其实呢我们把后面的全部删掉，只留下禅墨云之前的也是没问题的：</p><blockquote><p><a href="https://www.baidu.com/s?wd=禅墨云">https://www.baidu.com/s?wd=禅墨云</a></p></blockquote><p>有时url中携带的不只有一个参数，也就是说我们需要把搜索的词条变为动态的，所以我们需要url进行简单的处理：封装到字典中</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kw = <span class="built_in">input</span>(<span class="string">&#x27;enter a word：&#x27;</span>)</span><br><span class="line">    param = &#123;<span class="string">&#x27;wd&#x27;</span>:kw&#125;</span><br></pre></td></tr></table></figure></p><p>这时就可以把前面的url词条去掉，变为：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?</span><br></pre></td></tr></table></figure></p><p>这样，搜索结果就变成我们想要搜索的任何词条</p><h4 id="UA检测与伪装"><a href="#UA检测与伪装" class="headerlink" title="UA检测与伪装"></a>UA检测与伪装</h4><p><strong>UA检测</strong>：门户网站的服务器会检测对应请求载体的身份标识，如果检测到请求的载体身份标识为某一款浏览器说明这是一个正常的请求。但是，如果检测到请求的载体身份标识不是基于某一款浏览器，则表示该请求为不正常请求（爬虫检测），则服务端就会拒绝该次请求。</p><p><strong>UA伪装</strong>：让爬虫对应的请求载体身份标识伪装成某一款浏览器</p><p>其实只需要在url前面加上 <strong>headers</strong> 就可以了，里面包含了键值User-Agent，以及详细的value值</p><p>在浏览器中(以Chrome为例)点击F12，点击network，刷新后会出现很多文件，随便点击一个，打开headers，找到User-Agent对应处即可，然后复制其内容。</p><p><img src="https://img-blog.csdnimg.cn/20210128124342695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDkwNzcw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></p><p>之后的就是常规操作了。</p><h2 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h2><p>下面的就是完整的程序以及注释了，仅供学习</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --coding:utf-8 --</span></span><br><span class="line"><span class="comment">#UA:User-Agent(请求载体的身份标识)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#UA检测：门户网站的服务器会检测对应请求载体的身份标识，如果检测到请求的载体身份标识为某一款浏览器</span></span><br><span class="line"><span class="comment">#说明这是一个正常的请求。但是，如果检测到请求的载体身份标识不是基于某一款浏览器，则表示该请求为</span></span><br><span class="line"><span class="comment">#不正常请求（爬虫检测），则服务端就会拒绝该次请求。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#UA伪装：让爬虫对应的请求载体身份标识伪装成某一款浏览器</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">##UA伪装：将对应的User-Agent封装到一个字典中</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">    url = <span class="string">&#x27;https://www.baidu.com/s?&#x27;</span></span><br><span class="line">    <span class="comment">#处理url携带的参数：封装到字典中</span></span><br><span class="line">    kw = <span class="built_in">input</span>(<span class="string">&#x27;enter a word：&#x27;</span>)</span><br><span class="line">    param = &#123;<span class="string">&#x27;wd&#x27;</span>:kw&#125;</span><br><span class="line">    <span class="comment">#对指定的url发起的请求对应的url是携带参数的，并且请求过程中处理了参数</span></span><br><span class="line">    response = requests.get(url=url,params=param,headers=headers)</span><br><span class="line">    page_text = response.text</span><br><span class="line">    filename = kw+<span class="string">&#x27;.html&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(page_text)</span><br><span class="line">    <span class="built_in">print</span>(filename,<span class="string">&#x27;保存成功！&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>OK！这就是本篇文章全部内容了！</p><p>欢迎关注禅墨云，我们不见不散！</p><p>博客网站同步更新，网址：<strong>chanmoyun.gitee.io</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/20210127184252320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDkwNzcw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/categories/Python/"/>
    
    <category term="爬虫" scheme="https://chanmoyun.gitee.io/categories/Python/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/tags/Python/"/>
    
    <category term="爬虫" scheme="https://chanmoyun.gitee.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Requests第一血|3</title>
    <link href="https://chanmoyun.gitee.io/2021/01/27/Reptile-Learn/03.Requests%E7%AC%AC%E4%B8%80%E8%A1%80/"/>
    <id>https://chanmoyun.gitee.io/2021/01/27/Reptile-Learn/03.Requests%E7%AC%AC%E4%B8%80%E8%A1%80/</id>
    <published>2021-01-26T16:00:00.000Z</published>
    <updated>2024-01-09T03:08:53.333Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Requests第一血-3"><a href="#Requests第一血-3" class="headerlink" title="Requests第一血|3"></a>Requests第一血|3</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>你好，我是<strong>禅墨</strong>！</p><p>    <div id="aplayer-sZXYXCKR" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="399354289" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>今天发现一个有趣的现象，在家人眼里，我玩电子就是一个修手机、电器的！</p><p>然后去问了别人，他说他学的是农工，然后他妈妈就以为他以后毕业是开拖拉机的。</p><p>那么各位看官们，在你家长眼里，你所学的专业毕业后是 干什么的，我们评论区见！</p><p>从这篇文章开始，才算真正意义上的和代码打交道了，写代码之前，首先就要选择一个编辑器，哪个好用呢，当然是Pycharm啊，这还用问吗，对不对！</p><h2 id="网络请求模块"><a href="#网络请求模块" class="headerlink" title="网络请求模块"></a>网络请求模块</h2><ul><li><strong>urllib模块</strong> :较为古老，多用于Python2.x中，使用较为繁琐，但功能基本满足爬虫，有助于深入理解requests模块</li><li><strong>requests模块</strong>：Python中原生的一款基于网络请求的模块，功能非常强大，使用简单便捷，效率极高，作用于模拟浏览器发送请求。</li></ul><h2 id="Requests模块的编码顺序"><a href="#Requests模块的编码顺序" class="headerlink" title="Requests模块的编码顺序"></a>Requests模块的编码顺序</h2><ol><li><strong>指定url</strong>，所请求页面所在的网址</li><li><strong>发起请求</strong>，向服务器发送请求，得到一个响应对象</li><li><strong>获取响应数据</strong>，数据包含请求页面的源码信息</li><li><strong>持久化存储</strong>，将得到的数据存储到本地或数据库</li></ol><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>默认你已安装Python解释器，并且已经将其加入到环境当中</p><p>如果安装的是Pycharm,直接在设置里面安装即可，或者打开CMD</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure></p><p>pip 速度缓慢怎么办呢，那就换国内镜像源(以清华为例)，一劳永逸解决</p><p>首先打开CMD,输入：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config <span class="built_in">set</span> <span class="keyword">global</span>.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdnimg.cn/20210127184354507.png#pic_center" alt="在这里插入图片描述"></p><p>看到上图所示结果，找到生成的pip.ini，打开它，我们会看到:</p><p><img src="https://img-blog.csdnimg.cn/20210127184341163.png#pic_center" alt="在这里插入图片描述"></p><p>大功告成，就可以丝滑得下载第三方库了</p><h2 id="实战编码"><a href="#实战编码" class="headerlink" title="实战编码"></a>实战编码</h2><p><strong>需求</strong>：爬取百度首页数据并存储到本地</p><p>程序及注释：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --coding:utf-8 --</span></span><br><span class="line"><span class="comment"># 需求：爬取百度首页页面数据</span></span><br><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#step 1:指定url</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.baidu.com/&#x27;</span></span><br><span class="line">    <span class="comment">#step 2:发起请求</span></span><br><span class="line">    <span class="comment">#get方法会返回一个响应对象</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="comment">#step 3:获取响应数据.text 返回的是字符串形式的响应数据</span></span><br><span class="line">    page_text = response.text</span><br><span class="line">    <span class="built_in">print</span>(page_text)</span><br><span class="line">    <span class="comment">#step 4:持久化存储</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./baidu.html&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(page_text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;爬取结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>结束后会看到此工程文件夹里生成了一个网页：baidu.html</p><h2 id="文件操作说明"><a href="#文件操作说明" class="headerlink" title="文件操作说明"></a>文件操作说明</h2><blockquote><p>open(path, ‘-模式-‘,encoding=’UTF-8’)<br>即open(路径+文件名, 读写模式, 编码)</p></blockquote><p>读写模式：<br>r ：只读<br>r+ : 读写<br>w ： 新建（会对原有文件进行覆盖）<br>a ： 追加<br>b ： 二进制文件</p><p>常用的模式有：<br>“a” 以“追加”模式打开， (从 EOF 开始, 必要时创建新文件)<br>“a+” 以”读写”模式打开<br>“ab” 以”二进制 追加”模式打开<br>“ab+” 以”二进制 读写”模式打开</p><p>“w” 以”写”的方式打开<br>“w+” 以“读写”模式打开<br>“wb” 以“二进制 写”模式打开<br>“wb+” 以“二进制 读写”模式打开</p><p>“r+” 以”读写”模式打开<br>“rb” 以”二进制 读”模式打开<br>“rb+” 以”二进制 读写”模式打开</p><p>rU 或 Ua 以”读”方式打开, 同时提供通用换行符支持 (PEP 278)</p><p>需注意：<br>1、使用“w”模式。文件若存在，首先要清空，然后重新创建<br>2、使用“a”模式。把所有要写入文件的数据都追加到文件的末尾，即使你使用了seek（）指向文件的其他地方，如果文件不存在，将自动被创建。</p><p>3、f.read([size]) ：size未指定则返回整个文件，如果文件大小&gt;2倍内存则有问题。f.read()读到文件尾时返回”“(空字串)<br>4、file.readline() 返回一行<br>5、file.readline([size]) 返回包含size行的列表,size 未指定则返回全部行<br>6、”for line in f: print line” #通过迭代器访问<br>7、f.write(“hello\n”) #如果要写入字符串以外的数据,先将他转换为字符串.<br>8、f.tell() 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数).<br>9、f.seek(偏移量,[起始位置]) ： 用来移动文件指针<br>偏移量 : 单位“比特”,可正可负<br>起始位置 : 0 -文件头, 默认值; 1 -当前位置; 2 -文件尾<br>10、f.close() 关闭文件</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>OK！这就是本篇文章的内容了，欢迎关注<strong>禅墨云</strong>！</p><p>博客网站同步更新，网址：chanmoyun.gitee.io</p><blockquote><p><img src="https://img-blog.csdnimg.cn/20210127184252320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDkwNzcw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/categories/Python/"/>
    
    <category term="爬虫" scheme="https://chanmoyun.gitee.io/categories/Python/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/tags/Python/"/>
    
    <category term="爬虫" scheme="https://chanmoyun.gitee.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>HTTP&amp;HTTPS协议|2</title>
    <link href="https://chanmoyun.gitee.io/2021/01/24/Reptile-Learn/02.HTTP&amp;HTTPS%E5%8D%8F%E8%AE%AE/"/>
    <id>https://chanmoyun.gitee.io/2021/01/24/Reptile-Learn/02.HTTP&amp;HTTPS%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-01-23T16:00:00.000Z</published>
    <updated>2024-01-09T03:08:44.662Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="HTTP-amp-HTTPS协议"><a href="#HTTP-amp-HTTPS协议" class="headerlink" title="HTTP&amp;HTTPS协议"></a>HTTP&amp;HTTPS协议</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>你好，我是<strong>禅墨！</strong></p><p>    <div id="aplayer-bKHiCKvF" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1813568808" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>今天我们继续进行爬虫教程的第二篇文章，HTTP&amp;HTTPS协议！</p><p>HTTP&amp;HTTPS这两种超文本传输协议，大家或多或少都听说过，但是你真的了解他们吗？</p><p>你知道在网络爬虫中我们都怎么去运用吗？今天，我们就围绕这两种协议进行探究！</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p><strong>概念：</strong>服务器与客户端进行数据交互的一种形式。就比如人与人之间进行<strong>语言沟通</strong></p><h2 id="常用请求头信息"><a href="#常用请求头信息" class="headerlink" title="常用请求头信息"></a>常用请求头信息</h2><ul><li><p><strong>User-Agent :</strong>当前请求载体的身份标识，包含设备，浏览器等信息</p></li><li><p><img src="https://img-blog.csdnimg.cn/20210124153549470.png#pic_center" alt="在这里插入图片描述"></p></li></ul><ul><li><strong>Connection:</strong>请求完毕后，是断开连接还是保持连接两种形式</li></ul><h2 id="常用响应头信息"><a href="#常用响应头信息" class="headerlink" title="常用响应头信息"></a>常用响应头信息</h2><ul><li><strong>Content-Type：</strong>服务器响应回客户端的数据类型</li><li><img src="https://img-blog.csdnimg.cn/20210124153606133.png#pic_center" alt="在这里插入图片描述"></li></ul><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><ul><li>安全的超文本传输协议。数据进行过加密（证书密钥加密）</li></ul><h2 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h2><h4 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h4><p><img src="https://img-blog.csdnimg.cn/20210124153618605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDkwNzcw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>  客户端制定一种加密方式，对即将发送的数据进行加密，然后将加密过后的密文包括解密方式(密钥)传递给服务器，服务器用密钥进行对密文解密之后得到原文数据。</p><p><strong>弊端：</strong>密文密钥容易被第三方拦截，造成数据泄露</p><h4 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h4><p><img src="https://img-blog.csdnimg.cn/20210124153631956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDkwNzcw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>”私有密钥“和”公有密钥“</p><p>客户端按照服务器给定的公开密钥进行数据加密处理，然后将加密过后的密文发送给服务器，服务器接收到的密文再通过自己的私有密钥进行解密，最终得到原始数据。</p><p><strong>弊端：</strong>发送公开密钥的时候有被挟持的风险，处理效率较低，通讯过程中影响通讯速度</p><h4 id="证书密钥加密"><a href="#证书密钥加密" class="headerlink" title="证书密钥加密"></a>证书密钥加密</h4><p><img src="https://img-blog.csdnimg.cn/20210124153646482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDkwNzcw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>数字证书认证机构是客户端与服务器都可信赖的第三方机构</p><ul><li>服务器的开发者携带公开密钥，向数字证书认证机构提出公开密钥的申请，数字证书认证机构在认清申请者的身份，审核通过之后，会对开发者申请的公开密钥做数字签名，然后分配已签名的公开密钥，并将密钥放在证书里面，绑定子一起。</li><li>服务器将这份数字证书发送给客户端，因为客户端也认可证书机构，客户端可以通过数字证书中的数字签名来验证公钥的真伪，来确保服务器传过来的公开密钥是真实的。一般情况下，证书的数字签名是很难被伪造的，这取决于认证机构的公信力。一旦确认信息无误后，客户端就会通过公钥对数据进行加密发送，服务器接受以后用自己的私钥进行解密。</li></ul><p>这也是目前大多数在用的加密机制！</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>唉~~，疫情又开始肆虐了！</p><p>祝愿一切安好！疫情赶紧控制住！</p><p>钥进行解密。</p><p>这也是目前大多数在用的加密机制！</p><h2 id="写在后面-1"><a href="#写在后面-1" class="headerlink" title="写在后面"></a>写在后面</h2><p>唉~~，疫情又开始肆虐了！</p><p>祝愿一切安好！疫情赶紧控制住！</p><p>众志成城，共同抗疫，千万不要延迟开学啊……….</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/categories/Python/"/>
    
    <category term="爬虫" scheme="https://chanmoyun.gitee.io/categories/Python/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/tags/Python/"/>
    
    <category term="爬虫" scheme="https://chanmoyun.gitee.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>初探爬虫|1</title>
    <link href="https://chanmoyun.gitee.io/2021/01/23/Reptile-Learn/01.%E5%88%9D%E6%8E%A2%E7%88%AC%E8%99%AB/"/>
    <id>https://chanmoyun.gitee.io/2021/01/23/Reptile-Learn/01.%E5%88%9D%E6%8E%A2%E7%88%AC%E8%99%AB/</id>
    <published>2021-01-22T16:00:00.000Z</published>
    <updated>2024-01-09T03:08:35.265Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="初探爬虫"><a href="#初探爬虫" class="headerlink" title="初探爬虫"></a>初探爬虫</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>好久，没见！你好，我是<strong>禅墨</strong>！</p><p>    <div id="aplayer-JSEMiDit" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1465313631" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>2020是不幸的一年，还好已经过去，现在是2021！这是一个新的教程系列，就叫做爬虫与局子吧，哈哈哈！更新周期呢，得看心情，毕竟现在也是在复习！</p><p>去年做了一个Python进阶系列，只发了第一阶段的学习文章，其实后面的几个阶段，也早就已经写好，只是由于种种原因没有来的及发，呃~~，好吧种种原因就是“懒”！后续我会依次上传的，</p><p>先来思考以下几个问题</p><p> 1.你是否在夜深人静的时候，想看一些会让你更加睡不着的图片…</p><p> 2.你是否在考试或者面试前夕，想看一些具有针对性的题目…</p><p> 3.你是否想在杂乱的网络世界中获取你想要的数据…</p><h2 id="什么是爬虫"><a href="#什么是爬虫" class="headerlink" title="什么是爬虫"></a>什么是爬虫</h2><p>通过编写程序，模拟浏览器上网，然后就让其去互联网上抓取数据的过程。<br> 重点：模拟浏览器 抓取(整体与局部)</p><h2 id="爬虫的价值"><a href="#爬虫的价值" class="headerlink" title="爬虫的价值"></a>爬虫的价值</h2><p>—懂得都懂</p><h2 id="爬虫合法性探究"><a href="#爬虫合法性探究" class="headerlink" title="爬虫合法性探究"></a>爬虫合法性探究</h2><h4 id="爬虫合法性探究-1"><a href="#爬虫合法性探究-1" class="headerlink" title="爬虫合法性探究"></a>爬虫合法性探究</h4><ul><li>-爬虫在法律中不被禁止</li><li>-具有违法放风险(公开性信息合理)，利用爬虫攻击后台窃取后台数据即为违法</li><li>-分为善意爬虫和恶意爬虫<br>爬虫带来的风险体现在以下两个方面：<br>1.爬虫干扰了被访问网站的正常运营<br>2.爬虫抓取了受到法律保护的特定类型的数据或信息</li><li>如何避免进局子厄运？<br>1.时常优化自己的程序，避免干扰被访问网站的正常运行<br>2.在使用中，传播爬取到的数据时，审查抓取的内容，如果发现了涉及到用户隐私商业机密等敏感内容需要及时停止爬取及传播</li></ul><h2 id="爬虫在使用场景中分类"><a href="#爬虫在使用场景中分类" class="headerlink" title="爬虫在使用场景中分类"></a>爬虫在使用场景中分类</h2><p><strong>1.通用爬虫：</strong><br>抓取系统重要组成部分。抓取的是译者肮脏页面数据‘<br><strong>2.聚焦爬虫：</strong><br>是建立在通用爬虫基础上，住区页面中特定的局部内容<br><strong>3.增量式爬虫</strong>：<br>检测网站中数据更新的情况。只会抓取网站中最新更新出来的数据</p><h2 id="反爬机制"><a href="#反爬机制" class="headerlink" title="反爬机制"></a>反爬机制</h2><p>门户网站，可以通过指定相应的策略或者技术手段，防止爬虫程序进行网站数据的爬取</p><h2 id="反反爬策略"><a href="#反反爬策略" class="headerlink" title="反反爬策略"></a>反反爬策略</h2><p>爬虫程序可以通过制定相关的策略或者技术手段，破解门户网站中具备的反爬虫机制，从而可以获取门户网站的数据</p><h2 id="robots-txt君子协议"><a href="#robots-txt君子协议" class="headerlink" title="robots.txt君子协议"></a>robots.txt君子协议</h2><p>规定了网站中哪些数据可以被爬虫爬取，哪些数据不可以被爬取。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/categories/Python/"/>
    
    <category term="爬虫" scheme="https://chanmoyun.gitee.io/categories/Python/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/tags/Python/"/>
    
    <category term="爬虫" scheme="https://chanmoyun.gitee.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>考研&amp;就业，其实不难选！</title>
    <link href="https://chanmoyun.gitee.io/2020/08/01/Development/%E8%80%83%E7%A0%94&amp;%E5%B0%B1%E4%B8%9A%EF%BC%8C%E5%85%B6%E5%AE%9E%E4%B8%8D%E9%9A%BE%E9%80%89/"/>
    <id>https://chanmoyun.gitee.io/2020/08/01/Development/%E8%80%83%E7%A0%94&amp;%E5%B0%B1%E4%B8%9A%EF%BC%8C%E5%85%B6%E5%AE%9E%E4%B8%8D%E9%9A%BE%E9%80%89/</id>
    <published>2020-07-31T16:00:00.000Z</published>
    <updated>2024-01-11T09:16:34.351Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="考研-amp-就业，其实不难选！"><a href="#考研-amp-就业，其实不难选！" class="headerlink" title="考研&amp;就业，其实不难选！"></a>考研&amp;就业，其实不难选！</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>你好，我是<strong>禅墨</strong>！</p><p>    <div id="aplayer-fLYICIAX" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="440357778" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>之前对于这个问题，我经常这样回答：“考啊，肯定会去考啊，但是我如果第一年考不上的话，我不会再去用一年时间去备战”</p><p>现在不知不觉间大学时光就已经过去一半了，开学后我就是大三老学长了，然后就该准备考研的事情了，啊，时光好快好快！</p><p>再加上这次和两个研究生老学长出来，接触的也有一些名校毕业生，所以让我不得不重视起来这个问题，然后思考了很多，也查了很多，问了很多，写这篇文章第一就是做个细致的总结，第二是写给你知！</p><h2 id="考研香吗？"><a href="#考研香吗？" class="headerlink" title="考研香吗？"></a>考研香吗？</h2><p>我觉得这个标题取得不好，因为这是句废话！当然香啊。</p><p><strong>第一</strong>：目前大学生遍地都是，在就业方面的优势不太明显，甚至可以说是没有优势可言，甚至在之后的工作中升职，加薪，走上人生巅峰也没有研究生来的快，或者说是机会多更为合适。高学历确实是个很不错的敲门砖。</p><p><strong>第二</strong>：专业知识更为雄厚。在大学生期间，课程是比较多的，更多的是通识教育，所以能学到的真的很有限，当然这只是针对课程上，不排除像我这样的另类，因为兴趣走上了别的路。然而考研之后，会进行细分研究方向，讲究的专业性特别强，如果说大学学的东西在工作上基本用的不多，但是研究生的这种专业性就是一种很坚强的后盾。其实更重要的是，研究生分析问题以及解决问题的能力相对来说更有针对性，更具完整化。</p><p><strong>第三</strong>：资源财富。研究生期间，你会接触到更多的高知识人才，在你自己变得更优秀的同时，你身边的也会是一些优秀的人，“物以类聚，人以群分”不是没有道理的同时到时也会与一些企业来往密切，好好利用的话，这些都会成为你将来的资源。</p><p><strong>第四</strong>：换专业。说实话，有些专业前景不太好，当然我没有针对性，我只是针对就业来说，或者说是发现不是自己喜欢的专业，提不起一点兴趣，这个时候考研换专业也就是个很好的选择，虽然跨专业考研很难，但是不去努力一把怎么知道不行？</p><p>综上所述，考研能不香吗？</p><p>来说一个身边活生生 的例子：<strong>不透漏人名和公司。</strong>都是郑大毕业，一个研究生，一个本科生，都是搞计算机的，本科生工资拿到了6.8K，但是研究生工资却拿到了10K，这不是重点，研究生进的公司是华为旗下麒麟芯片的供货商，据说2021年将要上市，这是有多大的机遇啊。蚂蚁金服上市后，P8身价超亿，SO……</p><h2 id="选择？"><a href="#选择？" class="headerlink" title="选择？"></a>选择？</h2><p>说了那么多，考研和就业不过就是一个选择而已。</p><p>最近看到很多技术论坛，有些博主大咖在劝退考研党，但是吧我并不是特别赞同那些劝退的观点，我觉得还是要做些区分的，不同的人还是要根据自身的实际情况进行选择的。</p><p>1.二本或者三本。必须考研，这真的是转变的机会，具体走到那个地步，这个就只能看你自己的努力程度了。</p><p>2.双非考研党。如果本科学校是一个双非学校，对于大部分专业来说，还是去考研的好，双非学校的本科生出去工作，机会确实不大，当然轴承和液压专业除外啊。当然，考研还是要有选择的，本科是个双非，不乏有人都是因为高考的失利，但是吧，事实就是事实，既然不能改变，那就加倍努力，高考如果败过一次，考研就不能再失败一次，所以要么就不考，要么就奔着好的211或者985去，不然的话，其实用一年考研三年读研换了来的根本不值，也就是性价比不高，还不如去社会上多打拼打拼，积累经验！</p><p>3.211考研党。我感觉这个看学校吧，如果是特别强的211，很多专业如果考研兴趣不是特别强的话就可以直接就业，如果是普通的211建议还是考研冲一下，上个更好一点的顶尖院校。</p><p>4.985考研。这个我选择闭嘴……….</p><p>所以综上所述，不同的人，不同境地，不同选择。</p><h2 id="后述"><a href="#后述" class="headerlink" title="后述"></a>后述</h2><p>其实如果现在问我考研不，我会肯定地说：“考，并且是奔着好学校去，其他的不做考虑。”如果说第一年上岸失败的话，以前的我会绝对不会二战，觉得那是浪费青春的大好时光，现在的话我肯定会根据自己的程度进行斟酌选择的！</p><p>所以我个人是真的十分赞成考研的，因为现实教会我很多，也给了我考研的坚定信念！</p><p>有很多话，在心里想的很清楚，但是当我把他们打出来的时候，才发现表达并不清楚，终归自己文笔还是太烂了，这种文章也没怎么写过，但是我会努力进步的。</p><blockquote><p>我是<strong>禅墨</strong>，欢迎关注<strong>禅墨小栈</strong><br><img src="https://img-blog.csdnimg.cn/20200801233612103.gif#pic_center" alt="在这里插入图片描述"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="成长进阶" scheme="https://chanmoyun.gitee.io/categories/%E6%88%90%E9%95%BF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="成长进阶" scheme="https://chanmoyun.gitee.io/tags/%E6%88%90%E9%95%BF%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>关于一些想让你知道的反思和现实！</title>
    <link href="https://chanmoyun.gitee.io/2020/07/30/Development/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AE%A9%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E5%8F%8D%E6%80%9D%E5%92%8C%E7%8E%B0%E5%AE%9E%EF%BC%81/"/>
    <id>https://chanmoyun.gitee.io/2020/07/30/Development/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AE%A9%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E5%8F%8D%E6%80%9D%E5%92%8C%E7%8E%B0%E5%AE%9E%EF%BC%81/</id>
    <published>2020-07-29T16:00:00.000Z</published>
    <updated>2024-01-11T09:16:00.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="关于一些想让你知道的反思和现实！"><a href="#关于一些想让你知道的反思和现实！" class="headerlink" title="关于一些想让你知道的反思和现实！"></a>关于一些想让你知道的反思和现实！</h1><h2 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h2><p>你好，我是禅墨！</p><p>    <div id="aplayer-ROrcREKy" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1374051000" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>好久，不见！我消失了很长一段时间，先交代一下我去干嘛了：</p><ol><li>5.15-6.19呢，我们有考试，所有的考试，毕竟还是学生，然后还有两门课是有项目的，也有一定的难度，所以呢，就认真地去准备考试了。</li><li>6.20-7.3呢，考驾照，先是刷课时，我觉得我有必要吐槽一下 刷课时，所谓的刷课时就是在一个废弃厂子里转圈，一直转，没有加减速，没有红绿灯，就是单纯的转圈，消耗时间！然后真正的练车时间只有一周，我醉了啊！</li><li>7.8-至今，我在一个公司做实习生，公司挺大，在非标行业排进前五，还是挺厉害的，但是咱不讨论公司怎么样啊。等于说我把这个实习历程提前了两年。</li></ol><p>实习的这段时间，对我的冲击特别大，当然收获也是无与伦比的，我指的不是知识上的收获，而是从精神层面和眼界出发的，这也就是写下这篇文章的原因。</p><h2 id="后悔？"><a href="#后悔？" class="headerlink" title="后悔？"></a>后悔？</h2><p>我基本每学期都会问自己对这半年的选择后悔过吗？每年都会问自己对过去所做的后悔吗？</p><p>在没有经历这次的历练之前，我可能会直接回答，不会后悔！但是，今天再问，我犹豫了，然后思考了很久，“有遗憾，但是不后悔！”，这是我的答案！</p><p>为什么这样说呢？高中的最后一阶段，动力不足，不知道为啥，就是失去了那种感觉，所以我毫不意外地高考落败，然后选择了现在这个学校，<strong>河南科技大学</strong>，一个双非学校，其实我的分数可以让我有选择，但是由于我爷爷的癌症，让我在最后一天推掉了所以的省外学校，留在了河南！为什么不去河大？因为我更喜欢工科，河大在这方面有劣势。</p><p>我是和两个研究生一起过来的，其中一个是 从郑大调剂过来的，然后我们部门还有一个苏州大学的，然后从日常谈话中得知，原来，学校间差距是如此之大，我是曾设想过这个差距，但是还是没有料到，这个差距真的过于悬殊，甚至我在某个时候，是如此的自卑。我已经很努力地去做开拓自己眼界的事，去做提高自己能力的事，但是发现我们站在一个差距悬殊的平台，我竭尽全力去观望，看到的不过是人家平视的东西。我要比他们的付出多出至少一倍，我一直不相信阶级论，但是现实让我不得不去相信!</p><p>在他们的思想层面就超出了我们很多，这种东西无法表达，但是通过日常接触可以给你最直观的感受。还有就是生活条件，学习的资源，资源好且多，所有的生活条件很舒适，只为创造更好的学习环境。</p><p>所以我对自己过去很抱歉，但是为什么不后悔呢？</p><p>因为高考的失利确确实实对我影响很大，让我变得脚踏实地，变得很努力，让我学到了很多，现在的我比我大学前好千倍万倍，是那次让我第一次认识到长大，然后我也送走了爷爷。所以说有遗憾，不后悔！</p><p>还有就是，我很羡慕他们能接触到的资源以及他们所有的生活环境，但是有很大一部分人没有去好好利用，能够求知若渴地去利用资源的终归是少数，我虽然在这里，条件不如他们，但是我做到了小部分，所以这也是不会后悔，但有遗憾的原因！</p><h2 id="外面的世界很美好？"><a href="#外面的世界很美好？" class="headerlink" title="外面的世界很美好？"></a>外面的世界很美好？</h2><p>对，外面的世界十分美好。但是你得有欣赏这份美好的资本！</p><p>在学校的我们，总是幻想着毕业后的世界是多么的美好，尽管我已经考虑过社会的残酷，但是现实还是狠狠地打了我的脸。社会要远比我们想的残酷的多！</p><p>昆山，被称为最强县，七月平均房价为18821元/平，我们这个厂周围房价为14500元/平，厂子里的本科生工资为6.5k，211毕业的能拿8k，除去房租和日常生活开销能剩下四千块钱，连1/3平的房子都买不到，现实就是来打工比当地市民都要多，工作两年，你会发现，除了年龄你还是一无所有！你要知道郑州的平均房价不过在13710元/平而已，所以我也不想多说啥了。</p><p>还有一点，这些工厂都有和一些高校合作，他们会输入一些学生过来，组成生产线主力军，他们住的是十人间，虽说不会住满，每天从上午八点干到晚上九点，中间两个小时吃饭时间，基本全在干活，每个月只能拿到3.5k，没有双休！但是在这边的工厂里，这样的待遇还是比较高的了，关于这种合作，水太深！</p><p>我承认，外面的世界很美好，每天我们会看到朋友圈世界各地的美景，全是假期去哪个地方游玩，品尝哪些美食，感觉世界如此美好，有机会一定要去各地看看。但是你考虑过高昂的消费没有，一次说走就走的旅行需要多大的经济支撑，尤其是对普通孩子来说，这是父母用多少汗水换来的。对农村人来说每亩地，最高收成0.5吨粮食，除去交底，打药，上肥料，每亩地能赚不到1.3k。我本来不想说这些的，但是我确实忍不住！</p><p>毕竟能够外出好好游玩的只是少数人，大多数人还达不到那个经济水平。所以何冰老师说的“后浪”的生活条件，我并不认同，因为那代替不了大多数人！</p><p>外面的世界是真的很美好，但是我们得去拼搏，能够在这美好的世界中占有一席之地，有一定的资本，然后才能好好地欣赏这个世界。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>我从没写过这样的文章，这确实是我第一次写下这种类型地文章，原谅我不会讲故事，但是这确实是我的所思所想。希望对你有用！</p><p>下一篇我们聊聊考研和就业！</p><p>我是<strong>禅墨</strong>，欢迎关注微信公众号：<strong>禅墨小栈</strong></p><p>公众号进行了重新整改，以及官方认证，我仍保初心，不做任何商业用途，单纯分享技术，文章，以此交友！</p><p><img src="https://gitee.com/chanmoyun/pic-go/raw/master/2024-1/20200513234341292.gif" alt="禅墨小栈"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="成长进阶" scheme="https://chanmoyun.gitee.io/categories/%E6%88%90%E9%95%BF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="成长进阶" scheme="https://chanmoyun.gitee.io/tags/%E6%88%90%E9%95%BF%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>人脸识别-PCA特征脸(大BOSS)</title>
    <link href="https://chanmoyun.gitee.io/2020/07/24/Opencv-pro/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-PCA%E7%89%B9%E5%BE%81%E8%84%B8(%E5%A4%A7BOSS)/"/>
    <id>https://chanmoyun.gitee.io/2020/07/24/Opencv-pro/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-PCA%E7%89%B9%E5%BE%81%E8%84%B8(%E5%A4%A7BOSS)/</id>
    <published>2020-07-23T16:00:00.000Z</published>
    <updated>2024-01-09T03:06:21.284Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="人脸识别-PCA特征脸-大BOSS"><a href="#人脸识别-PCA特征脸-大BOSS" class="headerlink" title="人脸识别-PCA特征脸(大BOSS)"></a>人脸识别-PCA特征脸(大BOSS)</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>你好，我是禅墨！好久，不见！</p><p>    <div id="aplayer-MlUtsEjD" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1493863802" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#4997da" data-volume="0.6"    ></div></p><p>在忙了好久的各科考试之后，我终于闲下来了。</p><p>自从小凯上次输给我K210之后，一心想搞我，想要报仇。</p><p>小凯：阿墨，我给你说啊，我XX不服，给你三个小时，你给我做出来一个人脸识别，识别咱两个班一共57人，正确率不能低于96%，我赌100块钱！！！你得在我的监视下完成！</p><p>禅墨：确定？我怕你后悔！</p><p>小凯：确定！后悔，不存在的！你搞吧！！！小样！</p><p>思考了片刻决定用PCA实现！</p><h2 id="PCA特征脸"><a href="#PCA特征脸" class="headerlink" title="PCA特征脸"></a>PCA特征脸</h2><h3 id="PCA原理"><a href="#PCA原理" class="headerlink" title="PCA原理"></a>PCA原理</h3><p>PCA全名为主成分分析，其主要目的就是寻找一个矩阵，然后把原来的一组带有相关性的矩阵映射到寻找到的那个矩阵中，达到降维的目的。<strong>一般的，如果我们有M个N维向量，想将其变换为由R个N维向量表示的新空间中，那么首先将R个基按行组成矩阵A，然后将向量按列组成矩阵B，那么两矩阵的乘积AB就是变换结果，其中AB的第m列为A中第m列变换后的结果。</strong> 这句话就相当于找到了一个R行N列矩阵，然后乘一个N行M列矩阵，这样就得到了一个R行M列矩阵（其中R&lt;=N），达到降维的目的。其中M和N的含义为，M可以代表样本个数，而N代表每个样本的特征个数，所以最终结果就是把原来N个特征变为了R个特征，达到降维目的。 </p><h3 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h3><p> 1、构建一个样本集合$S ={T_1,T_2,…,T_M}$,$S$ 可以看做是一个N行M列的矩阵，也就是有M个样本，每个样本有N个特征。其中$T_i$是一个向量。<br>2、0均值化，为了便于计算方差的时候需要减去均值，所以如果本身样本是零均值的，就方便计算。  </p><p>$m = \frac{1}{M}\sum_{i=1}^{M}T_i$ ,这个是计算均值在python中可以使用  </p><pre><code>m = T.mean(axis = 1)  </code></pre><p>进行计算，其中axis = 1代表按行求均值。<br>然后$A = T -m$ 这个相当于把每个样本都减去均值，这样之后就相当于做了0均值化。   </p><p>3、计算投影矩阵（就是相当于上面的那个R行M列矩阵）<br>这个投影矩阵其实就是由$A<em>A^T$矩阵的特征向量构成，但是由于大多数情况$A</em>A^T$的维度太大（$A<em>A^T$是N行N列矩阵，如果是一张图片的话N就代表像素点个数，所以是相当大的），所以这个时候就利用数学的小技巧转化为先求$A^T</em>A$的特征向量矩阵V，其中V的每一列是一个特征向量，那么V是一个M行M列的矩阵，然后我们再从V中取出前R个最大特征值对应的特征向量，所以V就变成了M行R列矩阵，然后$C = AV$,那么这个C矩阵就是计算出的投影矩阵，C为一个N行R列的矩阵。  </p><p><img src="https://img-blog.csdnimg.cn/20200623172716684.jpg#pic_center" alt="在这里插入图片描述"></p><p>4、把原来样本进行投影  </p><p>第三步我们得到了一个N行R列的矩阵C，其中每一列是一个特征向量，但是我们在讲PCA原理的时候我们需要一个R行N列的矩阵，每一行是一个特征向量，所以我们可以使用$C^T$,所以我们投影后的样本变为$P = C^T A$ 其中P就是一个R行M列的矩阵，可以看出已经达到了降维的目的。  </p><h2 id="特征脸的实现"><a href="#特征脸的实现" class="headerlink" title="特征脸的实现"></a>特征脸的实现</h2><p>特征脸就是我们上面求得的C矩阵，所谓的基于特征脸进行的人脸识别，就是先把人脸映射到一个低纬空间，然后再计算映射后的脸之间的距离，把距离最近的两个特征脸归为同一个人的脸。  </p><p>所以特征脸的步骤为：  </p><ol><li>加载训练集中的脸，转为一个M行N列矩阵T </li><li>对T进行均值化  </li><li>找到T的投影矩阵C  </li><li>计算投影后的矩阵P  </li><li>设置简单的UI界面，进行图片选择与识别</li><li>加载一个测试图片，并利用C矩阵也把其投影为test_P  </li><li>计算test_P和P中每个样本的距离，最近的就是结果</li><li>通过结果检索对应的列表，找到并输出人名</li></ol><h2 id="Python程序解析"><a href="#Python程序解析" class="headerlink" title="Python程序解析"></a>Python程序解析</h2><h3 id="createDatabase函数"><a href="#createDatabase函数" class="headerlink" title="createDatabase函数"></a>createDatabase函数</h3><p>创建一个存放所有图片的数据库，具体的步骤看程序注释</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createDatabase</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="comment"># 查看路径下所有文件</span></span><br><span class="line">    TrainFiles = os.listdir(path)</span><br><span class="line">    <span class="comment"># 计算有几个文件（图片命名都是以 序号.jpg方式）</span></span><br><span class="line">    Train_Number = <span class="built_in">len</span>(TrainFiles) </span><br><span class="line">    T = []</span><br><span class="line">    <span class="comment"># 把所有图片转为1-D并存入T中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,Train_Number):</span><br><span class="line">        ip = path+<span class="string">&#x27;/&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">        image = cv.imread(ip,cv.IMREAD_GRAYSCALE)</span><br><span class="line">        image=cv.resize(image,img_size)</span><br><span class="line">        <span class="comment"># 转为1-D</span></span><br><span class="line">        image = image.reshape(image.size,<span class="number">1</span>)</span><br><span class="line">        T.append(image)        </span><br><span class="line">    T = np.array(T)</span><br><span class="line">    <span class="comment"># 不能直接T.reshape(T.shape[1],T.shape[0]) 这样会打乱顺序，</span></span><br><span class="line">    T = T.reshape(T.shape[<span class="number">0</span>],T.shape[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> np.mat(T).T</span><br></pre></td></tr></table></figure></p><h3 id="eigenfaceCore函数"><a href="#eigenfaceCore函数" class="headerlink" title="eigenfaceCore函数"></a>eigenfaceCore函数</h3><p>特征脸核心处理函数，对T进行数据处理操作，包括进行均值化，计算特征向量和特征值。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">eigenfaceCore</span>(<span class="params">T</span>):</span><br><span class="line">    <span class="comment"># 把均值变为0 axis = 1代表对各行求均值</span></span><br><span class="line">    m = T.mean(axis = <span class="number">1</span>)</span><br><span class="line">    A = T-m</span><br><span class="line">    L = (A.T)*(A)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算AT *A的 特征向量和特征值V是特征值，D是特征向量</span></span><br><span class="line">    <span class="comment"># L = np.cov(A,rowvar = 0)</span></span><br><span class="line">    V, D = np.linalg.eig(L)</span><br><span class="line">    L_eig = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(A.shape[<span class="number">1</span>]):</span><br><span class="line">            L_eig.append(D[:,i])</span><br><span class="line">    L_eig = np.mat(np.reshape(np.array(L_eig),(-<span class="number">1</span>,<span class="built_in">len</span>(L_eig))))</span><br><span class="line">    <span class="comment"># 计算 A *AT的特征向量</span></span><br><span class="line">    eigenface = A * L_eig</span><br><span class="line">    <span class="keyword">return</span> eigenface,m,A  </span><br></pre></td></tr></table></figure></p><h3 id="recognize函数"><a href="#recognize函数" class="headerlink" title="recognize函数"></a>recognize函数</h3><p>识别器函数：找到投影矩阵C,计算投影后的矩阵样本P，加载一个测试图片投影为test-p，然后在总样本P中进行比对，找到与test-p距离最近的样本，即为比对结果</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recognize</span>(<span class="params">testImage, eigenface,m,A</span>):</span><br><span class="line">    _,trainNumber = np.shape(eigenface)</span><br><span class="line">    <span class="comment"># 投影到特征脸后的</span></span><br><span class="line">    projectedImage = eigenface.T*(A)</span><br><span class="line">    <span class="comment"># 可解决中文路径不能打开问题(相当于英文路径下imread)</span></span><br><span class="line">    testImageArray = cv.imdecode(np.fromfile(testImage,dtype=np.uint8),cv.IMREAD_GRAYSCALE)</span><br><span class="line">    <span class="comment"># 转为1-D</span></span><br><span class="line">    testImageArray=cv.resize(testImageArray,img_size)</span><br><span class="line">    testImageArray = testImageArray.reshape(testImageArray.size,<span class="number">1</span>)</span><br><span class="line">    testImageArray = np.mat(np.array(testImageArray))</span><br><span class="line">    differenceTestImage = testImageArray - m</span><br><span class="line">    projectedTestImage = eigenface.T*(differenceTestImage)</span><br><span class="line">    distance = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, trainNumber):</span><br><span class="line">        q = projectedImage[:,i]</span><br><span class="line">        temp = np.linalg.norm(projectedTestImage - q)</span><br><span class="line">        distance.append(temp)</span><br><span class="line">  </span><br><span class="line">    minDistance = <span class="built_in">min</span>(distance)</span><br><span class="line">    index = distance.index(minDistance)</span><br><span class="line">    cv.imshow(<span class="string">&quot;recognize result&quot;</span>,cv.imread(<span class="string">&#x27;./TrainDatabase&#x27;</span>+<span class="string">&#x27;/&#x27;</span>+<span class="built_in">str</span>(index+<span class="number">1</span> )+<span class="string">&#x27;.jpg&#x27;</span>,cv.IMREAD_GRAYSCALE))</span><br><span class="line">    cv.waitKey()</span><br><span class="line">    <span class="keyword">return</span> index+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="构建可视化界面"><a href="#构建可视化界面" class="headerlink" title="构建可视化界面"></a>构建可视化界面</h3><p>制作一个简单的UI界面，通过简单的按钮选择需要识别人脸的图片，点击开始识别，输出结果，检索列表输出人名</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gui</span>():</span><br><span class="line">    root = tk.Tk()</span><br><span class="line">    root.title(<span class="string">&quot;pca face&quot;</span>)</span><br><span class="line">    <span class="comment">#点击选择图片时调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">select</span>():</span><br><span class="line">        filename = tkinter.filedialog.askopenfilename()</span><br><span class="line">        <span class="keyword">if</span> filename != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            s=filename</span><br><span class="line">            <span class="comment"># jpg图片文件名 和 路径。</span></span><br><span class="line">            im=Image.<span class="built_in">open</span>(s)</span><br><span class="line">            tkimg=ImageTk.PhotoImage(im)</span><br><span class="line">            <span class="comment"># 执行此函数之前， Tk() 必须已经实例化。</span></span><br><span class="line">            l.config(image=tkimg)</span><br><span class="line">            btn1.config(command=<span class="keyword">lambda</span> : example(filename))</span><br><span class="line">            btn1.config(text = <span class="string">&quot;开始识别&quot;</span>)</span><br><span class="line">            btn1.pack()</span><br><span class="line">            <span class="comment"># 重新绘制</span></span><br><span class="line">            root.mainloop()</span><br><span class="line">    <span class="comment"># 显示图片的位置</span></span><br><span class="line">    l = tk.Label(root)</span><br><span class="line">    l.pack()</span><br><span class="line">    </span><br><span class="line">    btn = tk.Button(root,text=<span class="string">&quot;选择识别的图片&quot;</span>,command=select)</span><br><span class="line">    btn.pack()</span><br><span class="line">    </span><br><span class="line">    btn1 = tk.Button(root) <span class="comment"># 开始识别按钮，刚开始不显示</span></span><br><span class="line">    root.mainloop()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    gui()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="图片问题"><a href="#图片问题" class="headerlink" title="图片问题"></a>图片问题</h2><p>我觉得有必要吐槽一下给的570张图片：jpg , png, jpeg, pmg各种格式各种分辨率应有尽有，真的是搞死我了！(一寸人脸照一般为92*112) 不过还好，只有七八十张，其他的就是正常的jpg格式，怎么办呢，我不可能说一张张进行裁剪，所以 就写个程序，批量裁剪吧。我直接给出核心代码，比较简单，就不废话说明了</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (path, dirnames, filenames) <span class="keyword">in</span> os.walk(input_dir):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        <span class="keyword">if</span> filename.endswith(<span class="string">&#x27;.jpg&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;正在处理第 %s 张图片&#x27;</span> % index)</span><br><span class="line">            img_path = path + <span class="string">&#x27;/&#x27;</span> + filename</span><br><span class="line">            <span class="built_in">print</span>(img_path)</span><br><span class="line">            img = cv.imdecode(np.fromfile(img_path,dtype=np.uint8),-<span class="number">1</span>)</span><br><span class="line">            new_img = cv.resize(img, (width, height))</span><br><span class="line">            imwritedir = output_dir + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(<span class="number">499</span>+index) + <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(imwritedir)</span><br><span class="line">            cv.imwrite(imwritedir, new_img)</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            key = cv.waitKey(<span class="number">30</span>) &amp; <span class="number">0xff</span></span><br><span class="line">            <span class="keyword">if</span> key == <span class="number">27</span>:</span><br><span class="line">                sys.exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>用过opencv的应该知道，读取中文路径会报错，怎么解决呢，也很简单</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.imdecode(np.fromfile(img_path,dtype=np.uint8),-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>用这个代替imread 完美！</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>计时结束：2：58：56！</p><p>哈哈哈，小凯又输了，收钱去！</p><p>凭良心说，这一篇博文干货满满。</p><h3 id="简单的总结："><a href="#简单的总结：" class="headerlink" title="简单的总结："></a>简单的总结：</h3><p>1.OpenCV中文路径解决方法</p><p>2.批量进行图片的简单裁剪</p><p>3.解析PCA算法原理</p><p>4.Python程序实现</p><p>欢迎关注：禅墨云</p><blockquote><p>公众号：<img src="https://img-blog.csdnimg.cn/20200623171922831.gif#pic_center" alt="在这里插入图片描述"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/categories/Python/"/>
    
    <category term="OpenCv" scheme="https://chanmoyun.gitee.io/categories/Python/OpenCv/"/>
    
    <category term="实战" scheme="https://chanmoyun.gitee.io/categories/Python/OpenCv/%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Python" scheme="https://chanmoyun.gitee.io/tags/Python/"/>
    
  </entry>
  
</feed>
